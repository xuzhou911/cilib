(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{127:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"metadata",(function(){return r})),n.d(t,"default",(function(){return p}));var a=n(1),i=n(9),o=(n(0),n(189)),l={id:"fit",title:"Fitness"},s=[{value:"The Fit Type",id:"the-fit-type",children:[{value:"Feasible",id:"feasible",children:[]},{value:"Infeasible and Adjusted",id:"infeasible-and-adjusted",children:[]}]},{value:"Min and Max Optimization",id:"min-and-max-optimization",children:[]},{value:"Comparison",id:"comparison",children:[{value:"dominance",id:"dominance",children:[]},{value:"quality",id:"quality",children:[]},{value:"compare",id:"compare",children:[]},{value:"fittest",id:"fittest",children:[]}]},{value:"Exercises",id:"exercises",children:[{value:"Question 1",id:"question-1",children:[]},{value:"Question 2",id:"question-2",children:[]},{value:"Question 3",id:"question-3",children:[]},{value:"Question 4",id:"question-4",children:[]},{value:"Question 5",id:"question-5",children:[]},{value:"Question 6",id:"question-6",children:[]},{value:"Question 7",id:"question-7",children:[]},{value:"Question 8",id:"question-8",children:[]},{value:"Question 9",id:"question-9",children:[]}]},{value:"Summary",id:"summary",children:[]}],r={id:"community-tutorial/fit",title:"Fitness",description:"After the last chapter you're now somewhat familiar with `Feasible` and `Infeasible`.",source:"@site/docs/community-tutorial/fit.md",permalink:"/docs/community-tutorial/fit"},b={rightToc:s,metadata:r},c="wrapper";function p(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)(c,Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"After the last chapter you're now somewhat familiar with ",Object(o.b)("inlineCode",{parentName:"p"},"Feasible")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Infeasible"),".\n",Object(o.b)("inlineCode",{parentName:"p"},"CILib")," offers this and more for dealing with the fitness of solutions.\nThese concepts will be the main focus of this chapter,\nas well as starting to put everything together of what we have learned thus far."),Object(o.b)("p",null,"We are going to cover the following"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The ",Object(o.b)("inlineCode",{parentName:"li"},"Fit")," data type, which we have seen before"),Object(o.b)("li",{parentName:"ul"},"The ",Object(o.b)("inlineCode",{parentName:"li"},"Opt")," data type, for optimization purposes"),Object(o.b)("li",{parentName:"ul"},"The ",Object(o.b)("inlineCode",{parentName:"li"},"Comparison")," class and its companion object")),Object(o.b)("h2",{id:"the-fit-type"},"The Fit Type"),Object(o.b)("p",null,"In the past we have seen ",Object(o.b)("inlineCode",{parentName:"p"},"Feasible")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Infeasible"),".\nBut, you might have noticed, there is a third type, ",Object(o.b)("inlineCode",{parentName:"p"},"Adjusted"),".\nThese types used to indicate information about a possible solution."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Feasible(v: Double)\n\nInfeasible(v: Double, violations: Int)\n\nAdjusted (original: Infeasible, adjust: Double)\n")),Object(o.b)("p",null,"And the purpose of this is to allow for pattern matching so that we may control the flow of logic.\nFor example"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:"invisible",invisible:!0}),"import cilib._\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:"silent",silent:!0}),"def control (fit: Fit) : Double = {\n    fit match {\n        case Feasible(v) => v\n        case Infeasible(_, _) => -1.0\n        case Adjusted (_, _) => -1.0\n    }\n}\n")),Object(o.b)("h3",{id:"feasible"},"Feasible"),Object(o.b)("div",{class:"callout callout-info"},"A data type to represent a feasible solution."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val f = Feasible.apply(5)\nFeasible.unapply(f)\n\n")),Object(o.b)("h3",{id:"infeasible-and-adjusted"},"Infeasible and Adjusted"),Object(o.b)("div",{class:"callout callout-info"},"Infeasible is a data type to represent an infeasible solution."),Object(o.b)("p",null,"From the ",Object(o.b)("inlineCode",{parentName:"p"},"Infeasible")," constructor we know that it requires a ",Object(o.b)("inlineCode",{parentName:"p"},"Double")," for our solution, and an ",Object(o.b)("inlineCode",{parentName:"p"},"Int"),"\nto show the amount of ",Object(o.b)("inlineCode",{parentName:"p"},"Constraints")," violated.\n",Object(o.b)("inlineCode",{parentName:"p"},"Infeasible")," offers an ",Object(o.b)("inlineCode",{parentName:"p"},"adjust")," method, ",Object(o.b)("inlineCode",{parentName:"p"},"adjust(f: Double => Double): Adjusted"),", which will create\nadjust the solution using the given parameter function."),Object(o.b)("div",{class:"callout callout-info"},"Adjusted indactes we have adjusted an `Infeasible` solution. It contains the `Infeasible` we had to adjust and the new adjusted value."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import scalaz._\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val badSolution = Infeasible(45.0, 1)\nbadSolution.adjust(x => x * 0.73)\n")),Object(o.b)("p",null,"With ",Object(o.b)("inlineCode",{parentName:"p"},"Adjust")," we are given a second chance at correcting an incorrect solution."),Object(o.b)("h2",{id:"min-and-max-optimization"},"Min and Max Optimization"),Object(o.b)("p",null,"Often we need to choose either the minimum or maximin solution out of our set of possible solutions.\nFor this, we have ",Object(o.b)("inlineCode",{parentName:"p"},"Min")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Max")," which extends ",Object(o.b)("inlineCode",{parentName:"p"},"Opt"),".\nThe operate as one would expect.\nThey do offer a function, ",Object(o.b)("inlineCode",{parentName:"p"},"objectiveOrder[A]: Order[Objective[A]]"),", which when supplied with two\n",Object(o.b)("inlineCode",{parentName:"p"},"Objectives")," results in an ",Object(o.b)("inlineCode",{parentName:"p"},"Order"),"."),Object(o.b)("h2",{id:"comparison"},"Comparison"),Object(o.b)("p",null,"Like the most of CILib, it's easy to deduce what a component does based on its name.\nWith ",Object(o.b)("inlineCode",{parentName:"p"},"Comparison")," we are going to be making... comparisons!\nThis is going to be a great addition to our arsenal of collected CILib components thus far.\nOur ",Object(o.b)("inlineCode",{parentName:"p"},"Comparison")," object offers us several methods"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"dominance(o: Opt): Comparison\nquality(o: Opt) = dominance(o)\ncompare[F[_],A](x: F[A], y: F[A])(implicit F: Fitness[F,A]): Comparison => F[A]\nfitter[F[_],A](x: F[A], y: F[A])(implicit F: Fitness[F,A]): Comparison => Boolean\n")),Object(o.b)("p",null,"Through the use of these methods we will be able to make our programs more elaborate and start getting more optimum results."),Object(o.b)("p",null,"First things first, ",Object(o.b)("inlineCode",{parentName:"p"},"implicits"),".\nYou might have noticed the ",Object(o.b)("inlineCode",{parentName:"p"},"(implicit F: Fitness[F,A])")," parameter.\nLater on you'll see we need not to worry about this as the implicits needed for the types we will\nbe using are defined within CILib.\nHowever, for this case and if you intend to use your own data types, we will\nneed to define the implicits ourselves.\nWe will be using ",Object(o.b)("inlineCode",{parentName:"p"},"NonEmptyList"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\nimport scalaz._\nimport Scalaz._\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12L)\nval cons = cilib.Equal(ConstraintFunction((l: NonEmptyList[Double]) => l.index(0).getOrElse(0.0)), 4.0)\nval e = Eval.constrained[NonEmptyList,Double]((l: NonEmptyList[Double]) => l.suml, List(cons))\n\nimplicit def i = new Fitness[NonEmptyList, Double] {\n    def fitness(l: NonEmptyList[Double]) = Option.apply(e.eval.run(rng)._2(l))\n}\n")),Object(o.b)("p",null,"We want to calculate the sum of the list with the constraint that the first number needs to be 4.\nWith that out of the way we may begin exploring the ",Object(o.b)("inlineCode",{parentName:"p"},"Comparison")," methods."),Object(o.b)("h3",{id:"dominance"},"dominance"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"dominance")," creates an instance of a ",Object(o.b)("inlineCode",{parentName:"p"},"Comparison")," type, based on the supplied ",Object(o.b)("inlineCode",{parentName:"p"},"Opt"),", that we may use."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val test1 = NonEmptyList(4.0, 5.0, 6.0)\nval test2 = NonEmptyList(4.0, 2.0, 33.0)\n\nval comparison = Comparison.dominance(Max)\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"comparison.apply(test1, test2)\n")),Object(o.b)("p",null,"So clearly ",Object(o.b)("inlineCode",{parentName:"p"},"test2")," is the better option, as we are calculating the sum of the list.\nWhat if ",Object(o.b)("inlineCode",{parentName:"p"},"test2's")," first number isn't 4?\nWell, then ",Object(o.b)("inlineCode",{parentName:"p"},"test1")," will be the better choice as ",Object(o.b)("inlineCode",{parentName:"p"},"test2")," will become infeasible.\nAh but what if both test1's and test2's first number is something other that 4?\nWell, both lists will become infeasible, and the first parameter will be returned."),Object(o.b)("h3",{id:"quality"},"quality"),Object(o.b)("p",null,"Does the same thing as ",Object(o.b)("inlineCode",{parentName:"p"},"dominance"),", just a different name."),Object(o.b)("h3",{id:"compare"},"compare"),Object(o.b)("p",null,"With this we can produce a function, that will work in a similar way to ",Object(o.b)("inlineCode",{parentName:"p"},"dominance"),".\nAll we need to do is supply a ",Object(o.b)("inlineCode",{parentName:"p"},"Comparison")," instance."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Comparison.compare(test1, test2)\nComparison.compare(test1, test2).apply(comparison)\n")),Object(o.b)("h3",{id:"fittest"},"fittest"),Object(o.b)("p",null,"Works in a similar fashion to ",Object(o.b)("inlineCode",{parentName:"p"},"compare")," but returns a function of ",Object(o.b)("inlineCode",{parentName:"p"},"Comparison => Boolean"),".\nThe function determines if the first parameter is fitter than the second."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Comparison.fitter(test2, test1).apply(comparison)\nComparison.fitter(test1, test2).apply(comparison)\n")),Object(o.b)("p",null,"And thats how we use the ",Object(o.b)("inlineCode",{parentName:"p"},"Comparison")," object!"),Object(o.b)("h2",{id:"exercises"},"Exercises"),Object(o.b)("p",null,"These questions are going to test your knowledge of everything involved in fitness and will require you to use the knowledge you have acquired thus far."),Object(o.b)("p",null,"The premise of these questions will focus around the following scenario."),Object(o.b)("p",null,"You are an assassin in ancient japan tasked with taking out an evil general.\nTo do this you will need to build a custom bow and arrow.\nYou visit the weapon smith with 400 coins in your pocket.\nYou can choose the type of the wood used for the bow and the type of material used for the tip of the arrow."),Object(o.b)("p",null,"For the bow, there are 5 different types/levels of woods. Type 5 being the best."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The price of the wood is the wood number * 40"),Object(o.b)("li",{parentName:"ul"},"Each increase in type of wood yields an additional 16 meters in distance. Type 1 wood will yield 16m, Type 2 32m and so on.")),Object(o.b)("p",null,"For the tip of the arrows, there are 10 types of materials to choose from. Type 10 being the best."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The price of the material is calculated at 40 * the material number."),Object(o.b)("li",{parentName:"ul"},"Each increase in type of material yields an additional 90 points in damage. Type 1 material will yield 90 damage points, Type 2 180 and so on."),Object(o.b)("li",{parentName:"ul"},"However with each increase in material type it reduces the distance by 4m."),Object(o.b)("li",{parentName:"ul"},"1 damage point takes away 1 health point")),Object(o.b)("p",null,"You know that the general's office is 38m from you hiding spot and that he is always wearing armor, giving him 520 health points.\nYou need to calculate the best custom bow and arrow for this problem, no AI is required, and return the solution in the following list format:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Distance, Damage, Bow Type, Arrow Type, Cost, Fitness"))),Object(o.b)("p",null,"You are given the following code to start with"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"import cilib._\nimport scalaz._\nimport Scalaz._\nimport spire.implicits._\nimport spire.math.Interval\n\nval coins = 400\nval rng = RNG.fromTime\n\ndef getGenBowType: Double = Math.floor(Dist.uniform(Interval(1.0, 5.0)).eval(RNG.fromTime))\ndef getGenArrowType(remainingCoins: Double): Double = Math.floor(Dist.uniform(Interval(1.0, remainingCoins / 40)).eval(RNG.fromTime))\n\ndef getBowCost(bowType: Double): Double = Math.pow(2.0, bowType).toInt * 10.0\ndef getArrowCost(arrowType: Double): Double = arrowType * 40.0\ndef getTotalCost(bowType: Double, arrowType: Double): Double = getBowCost(bowType) + getArrowCost(arrowType)\n\ndef getBowDistance(bowType: Double, arrowType: Double): Double = (bowType * 16.0 ) - (arrowType * 4.0)\ndef getArrowDamage(arrowType: Double): Double = arrowType * 90.0\n")),Object(o.b)("h3",{id:"question-1"},"Question 1"),Object(o.b)("p",null,"Create two methods with the following headers"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"generateValuesBasedOn(bowType: Double, arrowType: Double) : NonEmptyList[Double]\n\ngenerateValues : NonEmptyList[Double]\n")),Object(o.b)("p",null,"These must return a ",Object(o.b)("inlineCode",{parentName:"p"},"NonEmptyList[Double]")," with the format ",Object(o.b)("inlineCode",{parentName:"p"},"Distance, Damage, Bow Type, Arrow Type, Cost")),Object(o.b)("div",{class:"solution"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"def generateValuesBasedOn(bowType: Double, arrowType: Double) : NonEmptyList[Double] = {\n    val bowCost = getBowCost(bowType)\n    val arrowCost = getArrowCost(arrowType)\n    val distance = getBowDistance(bowType, arrowType)\n    val damage = getArrowDamage(arrowType)\n    NonEmptyList(distance, damage, bowType, arrowType, arrowCost + bowCost)\n}\n\ndef generateValues : NonEmptyList[Double] = {\n    val bowType = getGenBowType\n    val bowCost = getBowCost(bowType)\n    val arrowType = getGenArrowType(coins - bowCost)\n    val arrowCost = getArrowCost(arrowType)\n    val distance = getBowDistance(bowType, arrowType)\n    val damage = getArrowDamage(arrowType)\n    NonEmptyList(distance, damage, bowType, arrowType, arrowCost + bowCost)\n}\n"))),Object(o.b)("h3",{id:"question-2"},"Question 2"),Object(o.b)("p",null,"Implement a fitness method, ",Object(o.b)("inlineCode",{parentName:"p"},"fitness (l: NonEmptyList[Double]): Double"),", to be used in our evaluations."),Object(o.b)("div",{class:"solution"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"def fitness (l: NonEmptyList[Double]): Double = {\n    val distanceRating = (l.index(0).getOrElse(0.0) / 38.0) - 1.0\n    val damageRating = (l.index(1).getOrElse(0.0) / 520.0) - 1.0\n    100 - (distanceRating + damageRating) * 100\n}\n"))),Object(o.b)("h3",{id:"question-3"},"Question 3"),Object(o.b)("p",null,"Create the two ",Object(o.b)("inlineCode",{parentName:"p"},"Constraints")," from the information given, these will be used to guide our problem."),Object(o.b)("div",{class:"solution"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val distanceConstraint = GreaterThanEqual(ConstraintFunction((l: NonEmptyList[Double]) => l.index(0).getOrElse(0)) , 38)\nval damageConstraint = GreaterThanEqual(ConstraintFunction((l: NonEmptyList[Double]) => l.index(1).getOrElse(0)), 520)\n"))),Object(o.b)("h3",{id:"question-4"},"Question 4"),Object(o.b)("p",null,"Using the ",Object(o.b)("inlineCode",{parentName:"p"},"fitness")," method and ",Object(o.b)("inlineCode",{parentName:"p"},"Constraints")," that were created in the previous questions, create an instance of ",Object(o.b)("inlineCode",{parentName:"p"},"Eval")),Object(o.b)("div",{class:"solution"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val e = Eval.constrained[NonEmptyList, Double](fitness(_), List(damageConstraint, distanceConstraint))\n"))),Object(o.b)("h3",{id:"question-5"},"Question 5"),Object(o.b)("p",null,"Now that we have created the evaluation we will need some methods to extract the information from the the ",Object(o.b)("inlineCode",{parentName:"p"},"Objective")," result.\nKeeping this in mind, implement the following methods:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"getSolution (fit: Fit): Double\n\nevalObjective (objective: Objective[Double]): Double\n\ngetViolations (objective: Objective[Double]): List[Constraint[Double]]\n")),Object(o.b)("div",{class:"solution"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"def getSolution (fit: Fit): Double = {\n    fit match {\n        case Feasible(v) => v\n        case Infeasible(_, _) => -1.0\n        case Adjusted (_, _) => -1.0\n    }\n}\n\ndef evalObjective (objective: Objective[Double]): Double = {\n    objective match {\n        case Single(f, _) => getSolution(f)\n        case Multi(_) => -1.0\n    }\n}\n\ndef getViolations (objective: Objective[Double]): List[Constraint[Double]] = {\n    objective match {\n        case Single(_, l) => l\n        case Multi(_) => List()\n    }\n}\n"))),Object(o.b)("h3",{id:"question-6"},"Question 6"),Object(o.b)("p",null,"You should now be able to start generating possible solutions as well as evaluate them to get their fitness score.\nMore likely than not you will get an infeasible solution and low fitness score.\nInstead of continuously generating new possible solutions let's adjust our current one.\ncreate a method called ",Object(o.b)("inlineCode",{parentName:"p"},"adjust")," that will accept ",Object(o.b)("inlineCode",{parentName:"p"},"values: NonEmptyList[Double]")," and ",Object(o.b)("inlineCode",{parentName:"p"},"violations: List[Constraint[Double]]"),".\nBased on the given ",Object(o.b)("inlineCode",{parentName:"p"},"values")," list make the appropriate changes keeping the ",Object(o.b)("inlineCode",{parentName:"p"},"violations")," in mind."),Object(o.b)("div",{class:"solution"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"def adjust (values: NonEmptyList[Double], violations: List[Constraint[Double]]): NonEmptyList[Double] = {\n    val distanceConsViolated = violations.contains(distanceConstraint)\n    val damageConsViolated = violations.contains(damageConstraint)\n\n    val bowType = values.index(2).get\n    val arrowType = values.index(3).get\n    var result = values\n\n    if (distanceConsViolated && damageConsViolated){\n        result = generateValuesBasedOn(bowType + 1.0, arrowType + 1.0)\n    }else if (distanceConsViolated){\n        if (getTotalCost(bowType + 1.0, arrowType) > coins) result = generateValuesBasedOn(bowType + 1.0, arrowType - 1.0)\n        else result = generateValuesBasedOn(bowType + 1.0, arrowType)\n    }else if (damageConsViolated){\n        if (getTotalCost(bowType, arrowType + 1.0) > coins) result = generateValuesBasedOn(bowType - 1.0, arrowType + 1.0)\n        else result = generateValuesBasedOn(bowType, arrowType + 1.0)\n    }\n    result\n}\n"))),Object(o.b)("h3",{id:"question-7"},"Question 7"),Object(o.b)("p",null,"Now all thats left is to get the most cost effective solution for our custom bow and arrow.\nImplement a method called ",Object(o.b)("inlineCode",{parentName:"p"},"getCustomWeapon")," which will return a the details of the bow and arrow as well as the fitness score."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Distance, Damage, Bow Type, Arrow Type, Cost, Fitness"))),Object(o.b)("div",{class:"solution"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"def getCustomWeapon : NonEmptyList[Double] = {\n    var list = generateValues\n    var objective = e.eval.run(rng)._2(list)\n    var violations = getViolations(objective)\n    list = list.append(NonEmptyList(evalObjective(objective)))\n    while (violations.nonEmpty){\n        list = adjust(list, violations)\n        objective = e.eval.run(rng)._2(list)\n        violations = getViolations(objective)\n        list = list.append(NonEmptyList(evalObjective(objective)))\n\n    }\n    list\n}\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"getCustomWeapon\n"))),Object(o.b)("h3",{id:"question-8"},"Question 8"),Object(o.b)("p",null,"Upon further inspection you realize you have 1000 coins.\nYou then decide to rethink your custom bow and arrow.\nYou come to the conclusion to the arrow should deal as much damage as possible.\nChange the fitness method to return the amount of damage as the fitness score (also change the coins value to 1000)."),Object(o.b)("div",{class:"solution"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"def fitness (l: NonEmptyList[Double]): Double = l.index(1).get\n"))),Object(o.b)("h3",{id:"question-9"},"Question 9"),Object(o.b)("p",null,"Create the method ",Object(o.b)("inlineCode",{parentName:"p"},"highestDamageWeapon(n: Int): NonEmptyList[Double]")," which will generate n amount of custom bows and arrows.\nReturn the one that does the highest amount of damage."),Object(o.b)("div",{class:"solution"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"implicit def i = new Fitness[NonEmptyList, Double] {\n    def fitness(l: NonEmptyList[Double]) = Option.apply(e.eval.run(rng)._2(l))\n}\ndef highestDamageWeapon(weapons: Int): NonEmptyList[Double] ={\n    val comparison = Comparison.dominance(Max)\n    var result = getCustomWeapon\n    for (j <- 1 until weapons){\n        result = comparison.apply(getCustomWeapon, result)\n\n    }\n    result\n}\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"highestDamageWeapon(5)\n"))),Object(o.b)("h2",{id:"summary"},"Summary"),Object(o.b)("p",null,"We learnt about some amazing functionality of CILib with regards to fitness.\nWe got to test our knowledge of CILIb thus far by figuring out how to build a deadly custom bow and arrow.\nIts important to see how the various data types are starting to connect to one another.\nAnd with the data types defined for us, we only need to implement the finer details specific to our problem."),Object(o.b)("div",{class:"callout callout-info"},"They key take away points from this chapter are that",Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"By using pattern matching on ",Object(o.b)("inlineCode",{parentName:"li"},"Feasible"),", ",Object(o.b)("inlineCode",{parentName:"li"},"Infeasible")," and ",Object(o.b)("inlineCode",{parentName:"li"},"Adjusted")," we are able to control the logic as well as the validity of our solutions."),Object(o.b)("li",{parentName:"ul"},"We can define an optimization scheme, ",Object(o.b)("inlineCode",{parentName:"li"},"Max")," or ",Object(o.b)("inlineCode",{parentName:"li"},"Min"),"."),Object(o.b)("li",{parentName:"ul"},"Using the optimization scheme, we can begin to compare solutions (preferably ",Object(o.b)("inlineCode",{parentName:"li"},"Feasible"),")."))))}p.isMDXComponent=!0},189:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var b=i.a.createContext({}),c=function(e){var t=i.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):s({},t,{},e)),n},p=function(e){var t=c(e.components);return i.a.createElement(b.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,b=r(e,["components","mdxType","originalType","parentName"]),p=c(n),u=a,m=p["".concat(l,".").concat(u)]||p[u]||d[u]||o;return n?i.a.createElement(m,s({ref:t},b,{components:n})):i.a.createElement(m,s({ref:t},b))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=m;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s[u]="string"==typeof e?e:a,l[1]=s;for(var b=2;b<o;b++)l[b]=n[b];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);