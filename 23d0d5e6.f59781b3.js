(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{139:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"rightToc",(function(){return c})),a.d(t,"metadata",(function(){return r})),a.d(t,"default",(function(){return p}));var l=a(1),n=a(9),o=(a(0),a(189)),i={id:"pso",title:"PSO"},c=[{value:"Package",id:"package",children:[{value:"Particle",id:"particle",children:[]},{value:"Guide",id:"guide",children:[]},{value:"Pool",id:"pool",children:[]}]},{value:"Guide Object",id:"guide-object",children:[{value:"Identity",id:"identity",children:[]},{value:"Personal best",id:"personal-best",children:[]},{value:"Nearest best",id:"nearest-best",children:[]},{value:"Dominance",id:"dominance",children:[]},{value:"Global best",id:"global-best",children:[]},{value:"Local best",id:"local-best",children:[]},{value:"Von Neumann",id:"von-neumann",children:[]},{value:"Crossover",id:"crossover",children:[]},{value:"Nonlinear Model Predictive Control",id:"nonlinear-model-predictive-control",children:[]},{value:"Parent-Centric Crossover",id:"parent-centric-crossover",children:[]},{value:"Unimodal Normally Distributed Crossover",id:"unimodal-normally-distributed-crossover",children:[]}]},{value:"Pool Object",id:"pool-object",children:[{value:"PoolItem Object",id:"poolitem-object",children:[]}]},{value:"Creating Pools",id:"creating-pools",children:[]},{value:"Heterogeneous",id:"heterogeneous",children:[{value:"Types",id:"types",children:[]},{value:"Helper Functions",id:"helper-functions",children:[]},{value:"Algorithms",id:"algorithms",children:[]}]},{value:"PSO Methods",id:"pso-methods",children:[{value:"stdPosition",id:"stdposition",children:[]},{value:"stdVelocity",id:"stdvelocity",children:[]},{value:"evalParticle",id:"evalparticle",children:[]},{value:"updatePBest",id:"updatepbest",children:[]},{value:"updatePBestBounds",id:"updatepbestbounds",children:[]},{value:"updateVelocity",id:"updatevelocity",children:[]},{value:"singleComponentVelocity",id:"singlecomponentvelocity",children:[]},{value:"gcVelocity",id:"gcvelocity",children:[]},{value:"barebones",id:"barebones",children:[]},{value:"quantum",id:"quantum",children:[]},{value:"acceleration",id:"acceleration",children:[]},{value:"replace",id:"replace",children:[]},{value:"better",id:"better",children:[]},{value:"createParticle",id:"createparticle",children:[]}]},{value:"Default Algorithms",id:"default-algorithms",children:[{value:"Global best",id:"global-best-1",children:[]},{value:"Cognitive",id:"cognitive",children:[]},{value:"Social",id:"social",children:[]},{value:"Guaranteed Convergence PSO",id:"guaranteed-convergence-pso",children:[]},{value:"Charged",id:"charged",children:[]},{value:"Nonlinear Model Predictive Control",id:"nonlinear-model-predictive-control-1",children:[]},{value:"Crossover PSO",id:"crossover-pso",children:[]}]}],r={id:"community-tutorial/pso",title:"PSO",description:"The particle swarm optimization library of CILib is one of the most extensive libraries.",source:"@site/docs/community-tutorial/pso.md",permalink:"/docs/community-tutorial/pso"},b={rightToc:c,metadata:r},s="wrapper";function p(e){var t=e.components,a=Object(n.a)(e,["components"]);return Object(o.b)(s,Object(l.a)({},b,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"The particle swarm optimization library of CILib is one of the most extensive libraries.\nWhile offering numerous pso components and algorithms it's best to begin with the basics of the library and then progressively work from there."),Object(o.b)("p",null,"To include this library in your project you can add the following to your list of library dependencies"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},'"net.cilib" %% "cilib-pso" % "2.0"')),Object(o.b)("p",null,"There are also several examples of implementations of PSOs in the example package. You can view the example package ","[here][example-package]","."),Object(o.b)("h2",{id:"package"},"Package"),Object(o.b)("p",null,"The package object has 3 valuable types specific to pso.\nThese being:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Particle")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Guide")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Pool"))),Object(o.b)("h3",{id:"particle"},"Particle"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Particle")," is simply another name for ",Object(o.b)("inlineCode",{parentName:"p"},"Entity"),"."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"type Particle[S,A] = Entity[S,A]")),Object(o.b)("h3",{id:"guide"},"Guide"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Guide")," represents guides that we have seen in pso algorithms to guide particles."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"type Guide[S,A] = (NonEmptyList[Particle[S,A]], Particle[S,A]) => Step[A,Position[A]]")),Object(o.b)("p",null,"As use can see ",Object(o.b)("inlineCode",{parentName:"p"},"Guide")," features a type of a method that takes a collection of particles as well a single particle that will result in a ",Object(o.b)("inlineCode",{parentName:"p"},"Step"),".\nin short, a ",Object(o.b)("inlineCode",{parentName:"p"},"Guide")," is a selection followed by a comparison, wrapped up in a ",Object(o.b)("inlineCode",{parentName:"p"},"Step"),"."),Object(o.b)("h3",{id:"pool"},"Pool"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Pool")," represents a pool.\nThis type is a non empty list of ",Object(o.b)("inlineCode",{parentName:"p"},"PoolItems"),", which we will see shortly."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"type Pool[A] = NonEmptyList[PoolItem[A]]")),Object(o.b)("h2",{id:"guide-object"},"Guide Object"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Guide")," object is a companion object to the ",Object(o.b)("inlineCode",{parentName:"p"},"Guide"),".\nIt offers us the following methods to produce guides:"),Object(o.b)("h3",{id:"identity"},"Identity"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"identity[S,F[_],A]: Guide[S,A]\n")),Object(o.b)("h3",{id:"personal-best"},"Personal best"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"pbest[S,A](implicit M: HasMemory[S,A]): Guide[S,A]\n")),Object(o.b)("h3",{id:"nearest-best"},"Nearest best"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"nbest[S](neighbourhood: IndexSelection[Particle[S,Double]])(implicit M: HasMemory[S,Double]): Guide[S,Double]\n")),Object(o.b)("h3",{id:"dominance"},"Dominance"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"dominance[S](selection: IndexSelection[Particle[S,Double]]): Guide[S,Double]\n")),Object(o.b)("h3",{id:"global-best"},"Global best"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"gbest[S](implicit M: HasMemory[S,Double]): Guide[S,Double]\n")),Object(o.b)("h3",{id:"local-best"},"Local best"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"lbest[S](n: Int)(implicit M: HasMemory[S,Double]): Guide[S,Double]\n")),Object(o.b)("h3",{id:"von-neumann"},"Von Neumann"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"vonNeumann[S](implicit M: HasMemory[S,Double]): Guide[S,Double]\n")),Object(o.b)("h3",{id:"crossover"},"Crossover"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"crossover[S](parentAttractors: NonEmptyList[Position[Double]], op: Crossover[Double]): Guide[S,Double]\n")),Object(o.b)("h3",{id:"nonlinear-model-predictive-control"},"Nonlinear Model Predictive Control"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"nmpc[S](prob: Double): Guide[S,Double]\n")),Object(o.b)("h3",{id:"parent-centric-crossover"},"Parent-Centric Crossover"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"pcx[S](s1: Double, s2: Double)(implicit M: HasMemory[S,Double]): Guide[S,Double]\n")),Object(o.b)("h3",{id:"unimodal-normally-distributed-crossover"},"Unimodal Normally Distributed Crossover"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"undx[S](s1: Double, s2: Double)(implicit M: HasMemory[S,Double]): Guide[S,Double]\n")),Object(o.b)("h2",{id:"pool-object"},"Pool Object"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Pool")," object allows us to create instances of ",Object(o.b)("inlineCode",{parentName:"p"},"Pools")," which are non empty lists containing ",Object(o.b)("inlineCode",{parentName:"p"},"PoolItems"),".\nTo understand ",Object(o.b)("inlineCode",{parentName:"p"},"Pools")," we need to first see how ",Object(o.b)("inlineCode",{parentName:"p"},"PoolItems")," work."),Object(o.b)("h3",{id:"poolitem-object"},"PoolItem Object"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"PoolItem")," object allows us to create ",Object(o.b)("inlineCode",{parentName:"p"},"PoolItems")," which assign a score to some item.\nThe following code will demonstrate this."),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"import cilib._\nimport cilib.pso._\nimport spire.implicits.{eu => _, _}\nimport spire.math.Interval\n\nval interval = Interval(-5.12,5.12)^1\nval rng = RNG.init(12)\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"val particle = Position.createPosition(interval).map(p => Entity(Mem(p, p.zeroed), p)).eval(rng)\n\nval poolitem = PoolItem.apply(particle, 1.25)\n")),Object(o.b)("p",null,"Now that we have created a ",Object(o.b)("inlineCode",{parentName:"p"},"PoolItem")," we are able use the class methods."),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"poolitem.score // Will yield the score\npoolitem.reward(0.54) // Will Modify the score\npoolitem.change(particle) // Change the item\n")),Object(o.b)("h2",{id:"creating-pools"},"Creating Pools"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Pool")," object is very easy to use.\nNearly all of the methods take at least a ",Object(o.b)("inlineCode",{parentName:"p"},"NonEmptyList[A]")," which represent our items.\nIn these examples, for simplicity purposes, we will be using ",Object(o.b)("inlineCode",{parentName:"p"},"Double")," as our type.\nLet's say we needed to create a pool where each item within the pool had the same score.\nTo do this we would use ",Object(o.b)("inlineCode",{parentName:"p"},"mkPool"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"import scalaz._\nimport Scalaz._\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"val doubles = RVar.doubles(5).eval(rng).toNel.get\n\nval pool1 = Pool.mkPool(0.85, doubles)\n")),Object(o.b)("p",null,"Now each item in the pool has a score of ",Object(o.b)("inlineCode",{parentName:"p"},"0.85"),".\nSimilarly we could use ",Object(o.b)("inlineCode",{parentName:"p"},"mkEvenPool")," which will give each item a score based on the amount of items in the pool."),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"val pool2 = Pool.mkEvenPool(doubles)\n")),Object(o.b)("p",null,"Or ",Object(o.b)("inlineCode",{parentName:"p"},"mkZeroPool")," which will give each item a score of 0."),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"val pool2 = Pool.mkEvenPool(doubles)\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"mkPoolListScore")," when provided with a ",Object(o.b)("inlineCode",{parentName:"p"},"Pool")," will turn the score of each item into a ",Object(o.b)("inlineCode",{parentName:"p"},"List"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"Pool.mkPoolListScore(pool1)\n")),Object(o.b)("p",null,"We can also update a ",Object(o.b)("inlineCode",{parentName:"p"},"Pool's")," items by using ",Object(o.b)("inlineCode",{parentName:"p"},"mkFromOldPool"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"val newDoubles = RVar.doubles(5).eval(RNG.init(12)).toNel.get\nPool.mkFromOldPool(pool1, newDoubles)\n")),Object(o.b)("p",null,"Lastly, we have the method ",Object(o.b)("inlineCode",{parentName:"p"},"updateUserBehaviours"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"updateUserBehaviours[A, B](oldP: Pool[B], newP: Pool[B])(xs: NonEmptyList[User[A,B]])\n")),Object(o.b)("p",null,"As you can see, it makes use of a ",Object(o.b)("inlineCode",{parentName:"p"},"User")," type.\n",Object(o.b)("inlineCode",{parentName:"p"},"User")," is simply some user representation, such as ",Object(o.b)("inlineCode",{parentName:"p"},"Particle")," matched with a ",Object(o.b)("inlineCode",{parentName:"p"},"PoolItem"),"."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"User[A, B](user: A, item: PoolItem[B])")),Object(o.b)("p",null,"The purpose of this is to give updated behaviours."),Object(o.b)("h2",{id:"heterogeneous"},"Heterogeneous"),Object(o.b)("p",null,"So far we have seen a lot from the pso package.\nAt this point it has mostly been centered around learning the basics of the package.\nFrom here on out we will be looking at all the related methods to build pso algorithms as well as the algorithms themselves.\nHowever, these sections will feel more like documentation as they are methods based on existing pso knowledge and not anything specific to CILib."),Object(o.b)("h3",{id:"types"},"Types"),Object(o.b)("p",null,"There are several predefined types that are used in the ",Object(o.b)("inlineCode",{parentName:"p"},"Heterogeneous")," object that represent components we would see in heterogeneous PSOs."),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"type Behaviour[S, A, B] = NonEmptyList[Entity[S, A]] => Entity[S, A] => StepS[A, B, Entity[S, A]]\n\ntype SI[S, A, B] = StepS[A, S, B]\n\ntype HEntity[S, A, B] = User[Entity[S, A], B]\n\ntype HEntityB[S, A, B] = HEntity[S, A, Behaviour[S, A, B]]\n")),Object(o.b)("h3",{id:"helper-functions"},"Helper Functions"),Object(o.b)("h4",{id:"updatestagnation"},"updateStagnation"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"updateStagnation[S, A](p: Entity[S,A])(implicit M: HasMemory[S,A], S: HasPBestStagnation[S]): Step[A, Entity[S,A]]\n")),Object(o.b)("h4",{id:"assignrandom"},"assignRandom"),Object(o.b)("p",null,"Creates a population with behaviours."),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"assignRandom[A, B, C](implicit M: MonadState[StepS[C,Pool[B],?], Pool[B]]): NonEmptyList[A] => StepS[C,Pool[B],NonEmptyList[User[A, B]]]\n")),Object(o.b)("h4",{id:"pbeststagnated"},"pbestStagnated"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"pbestStagnated[S, A, B](threshold: Int)(implicit S: HasPBestStagnation[S]): HEntity[S,A,B] => Boolean\n")),Object(o.b)("h4",{id:"resetstagnation"},"resetStagnation"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"resetStagnation[S, A, B](implicit S: HasPBestStagnation[S]): HEntity[S,A,B] => HEntity[S,A,B]\n")),Object(o.b)("h4",{id:"poolselectrandom"},"poolSelectRandom"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"poolSelectRandom[A, B, C]: NonEmptyList[User[A, B]] => User[A, B] => StepS[C,Pool[B],User[A, B]]\n")),Object(o.b)("h4",{id:"poolselecttournament"},"poolSelectTournament"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"poolSelectTournament[A, B, C](k: Int): NonEmptyList[User[A, B]] => User[A, B] => StepS[C,Pool[B],User[A, B]]\n")),Object(o.b)("h4",{id:"usebehaviour"},"useBehaviour"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"useBehaviour[S, A, B]: NonEmptyList[HEntityB[S, A, B]] => HEntityB[S, A, B] => StepS[A, B, HEntityB[S, A, B]]\n")),Object(o.b)("h4",{id:"incrementone"},"incrementOne"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"incrementOne[S, A, B](implicit M: MonadState[StepS[A,Pool[Behaviour[S,A,B]],?],Pool[Behaviour[S,A,B]]]): HEntityB[S, A, B] => HEntityB[S, A, B] => StepS[A,Pool[Behaviour[S,A,B]],Pool[Behaviour[S,A,B]]]\n")),Object(o.b)("h4",{id:"updatestagnation-1"},"updateStagnation"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"nullPoolUpdate[S, A, B]: HEntityB[S, A, B] => HEntityB[S, A, B] => StepS[A,Pool[Behaviour[S,A,B]],Pool[Behaviour[S,A,B]]]\n")),Object(o.b)("h3",{id:"algorithms"},"Algorithms"),Object(o.b)("p",null,"Keep in mind that all these algorithms will return the same type."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"NonEmptyList[Particle[S,Double]] => Particle[S,Double] => Step[Double,Particle[S,Double]]")),Object(o.b)("h4",{id:"generic-heterogeneous-pso"},"Generic Heterogeneous PSO"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"genericHPSO[S, A, B](\n    schedule: HEntityB[S, A, B] => Boolean,\n    selector: NonEmptyList[HEntityB[S, A, B]] => HEntityB[S, A, B] => StepS[A, Pool[Behaviour[S, A, B]], HEntityB[S, A, B]],\n    updater: HEntityB[S, A, B] => HEntityB[S, A, B] => StepS[A, Pool[Behaviour[S, A, B]], Pool[Behaviour[S, A, B]]]\n)\n")),Object(o.b)("h4",{id:"dynamic-heterogeneous-pso"},"Dynamic Heterogeneous PSO"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"dHPSO[S: HasPBestStagnation, A, B](stagThreshold: Int)\n")),Object(o.b)("h4",{id:"fuzzy-cluster-pso"},"Fuzzy Cluster PSO"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"fkPSO[S: HasPBestStagnation, A, B](stagThreshold: Int, tournSize: Int)\n")),Object(o.b)("h2",{id:"pso-methods"},"PSO Methods"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"PSO")," object supports all the necessary methods required to build a pso in CILib.\nThe majority of these methods will return a ",Object(o.b)("inlineCode",{parentName:"p"},"Step")," for the purpose of chaining them together.\nFor example"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"collection => x => for {\n      cog     <- cognitive(collection, x)\n      soc     <- social(collection, x)\n      v       <- stdVelocity(x, soc, cog, w, c1, c2)\n      p       <- stdPosition(x, v)\n      p2      <- evalParticle(p)\n      p3      <- updateVelocity(p2, v)\n      updated <- updatePBest(p3)\n    } yield updated\n")),Object(o.b)("p",null,"This is in contrast to some other methods which exist as helper methods."),Object(o.b)("h3",{id:"stdposition"},"stdPosition"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"stdPosition[S,A](\n    c: Particle[S,A],\n    v: Position[A]\n)(implicit A: Module[Position[A],A]): Step[A,Particle[S,A]]\n")),Object(o.b)("h3",{id:"stdvelocity"},"stdVelocity"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"stdVelocity[S](\n    entity: Particle[S,Double],\n    social: Position[Double],\n    cognitive: Position[Double],\n    w: Double,\n    c1: Double,\n    c2: Double\n)(implicit V: HasVelocity[S,Double]): Step[Double,Position[Double]]\n")),Object(o.b)("h3",{id:"evalparticle"},"evalParticle"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"evalParticle[S](entity: Particle[S,Double]) = Step.eval[S,Double](x => x)(entity)\n")),Object(o.b)("h3",{id:"updatepbest"},"updatePBest"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"updatePBest[S](p: Particle[S,Double])(implicit M: HasMemory[S,Double]): Step[Double,Particle[S,Double]]\n")),Object(o.b)("h3",{id:"updatepbestbounds"},"updatePBestBounds"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"updatePBestBounds[S](p: Particle[S,Double])(implicit M: HasMemory[S,Double]): Step[Double,Particle[S,Double]]\n")),Object(o.b)("h3",{id:"updatevelocity"},"updateVelocity"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"updateVelocity[S](p: Particle[S,Double], v: Position[Double])(implicit V: HasVelocity[S,Double]): Step[Double,Particle[S,Double]]\n")),Object(o.b)("h3",{id:"singlecomponentvelocity"},"singleComponentVelocity"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"singleComponentVelocity[S](\n    entity: Particle[S,Double],\n    component: Position[Double],\n    w: Double,\n    c: Double\n)(implicit V: HasVelocity[S,Double]): Step[Double,Position[Double]]\n")),Object(o.b)("h3",{id:"gcvelocity"},"gcVelocity"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"gcVelocity")," method has a unique parameter that is of type ",Object(o.b)("inlineCode",{parentName:"p"},"GCParams"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"gcVelocity[S](\n    entity: Particle[S,Double],\n    nbest: Position[Double],\n    w: Double,\n    s: GCParams\n)(implicit V: HasVelocity[S,Double]): Step[Double,Position[Double]]\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"GCParams")," has the following class constructor"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"final case class GCParams(p: Double, successes: Int, failures: Int, e_s: Double, e_f: Double)\n")),Object(o.b)("p",null,"We are also provided with a ",Object(o.b)("inlineCode",{parentName:"p"},"defaultGCParams")," that will return a ",Object(o.b)("inlineCode",{parentName:"p"},"GCParams")," with default values."),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"defaultGCParams = GCParams(p = 1.0, successes = 0, failures = 0, e_s = 15, e_f = 5)\nfinal case class GCParams(p: Double, successes: Int, failures: Int, e_s: Double, e_f: Double)\n")),Object(o.b)("h3",{id:"barebones"},"barebones"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"barebones[S](p: Particle[S,Double], global: Position[Double])(implicit M: HasMemory[S,Double])\n")),Object(o.b)("h3",{id:"quantum"},"quantum"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"quantum[S]( // This is relative to the origin\n    x: Particle[S,Double], // passed in only to get the length of the vector\n    r: RVar[Double],       // magnitude of the radius for the hypersphere\n    dist: (Double, Double) => RVar[Double] // Distribution used\n  ): Step[Double,Position[Double]]\n")),Object(o.b)("h3",{id:"acceleration"},"acceleration"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"acceleration[S](\n    collection: NonEmptyList[Particle[S,Double]],\n    x: Particle[S,Double],\n    distance: (Position[Double], Position[Double]) => Double,\n    rp: Double,\n    rc: Double)(\n    implicit C: HasCharge[S]): Step[Double,Position[Double]]\n")),Object(o.b)("h3",{id:"replace"},"replace"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"replace[S](entity: Particle[S,Double], p: Position[Double]): Step[Double,Particle[S,Double]]\n")),Object(o.b)("h3",{id:"better"},"better"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"better[S,A](a: Particle[S,A], b: Particle[S,A]): Step[A,Boolean]\n")),Object(o.b)("h3",{id:"createparticle"},"createParticle"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"createParticle[S](f: Position[Double] => Particle[S,Double])(pos: Position[Double]): Particle[S,Double]\n")),Object(o.b)("h2",{id:"default-algorithms"},"Default Algorithms"),Object(o.b)("p",null,"CILib has several predefined pso algorithms for us to use in the ",Object(o.b)("inlineCode",{parentName:"p"},"Defaults"),".\nKeep in mind that all these algorithms will return the same type."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"NonEmptyList[Particle[S,Double]] => Particle[S,Double] => Step[Double,Particle[S,Double]]")),Object(o.b)("p",null,"This is stated before hand to avoid code repetition."),Object(o.b)("h3",{id:"global-best-1"},"Global best"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"gbest[S](\n    w: Double,\n    c1: Double,\n    c2: Double,\n    cognitive: Guide[S,Double],\n    social: Guide[S,Double]\n)(implicit M: HasMemory[S,Double], V: HasVelocity[S,Double])\n")),Object(o.b)("h3",{id:"cognitive"},"Cognitive"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"cognitive[S](\n    w: Double,\n    c1: Double,\n    cognitive: Guide[S,Double]\n)(implicit M: HasMemory[S,Double], V: HasVelocity[S,Double])\n")),Object(o.b)("h3",{id:"social"},"Social"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"social[S](\n    w: Double,\n    c1: Double,\n    social: Guide[S,Double]\n)(implicit M: HasMemory[S,Double], V: HasVelocity[S,Double])\n")),Object(o.b)("h3",{id:"guaranteed-convergence-pso"},"Guaranteed Convergence PSO"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"gcpso[S](\n    w: Double,\n    c1: Double,\n    c2: Double,\n    cognitive: Guide[S,Double])(implicit M: HasMemory[S,Double], V: HasVelocity[S,Double]\n): NonEmptyList[Particle[S,Double]] => Particle[S,Double] => StepS[Double, GCParams, Particle[S,Double]]\n")),Object(o.b)("h3",{id:"charged"},"Charged"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"charged[S:HasCharge](\n    w: Double,\n    c1: Double,\n    c2: Double,\n    cognitive: Guide[S,Double],\n    social: Guide[S,Double],\n    distance: (Position[Double], Position[Double]) => Double,\n    rp: Double,\n    rc: Double\n)(implicit M:HasMemory[S,Double], V:HasVelocity[S,Double])\n")),Object(o.b)("h3",{id:"nonlinear-model-predictive-control-1"},"Nonlinear Model Predictive Control"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"nmpc[S](\n    guide: Guide[S,Double]\n)(implicit M: HasMemory[S,Double])\n")),Object(o.b)("h3",{id:"crossover-pso"},"Crossover PSO"),Object(o.b)("pre",null,Object(o.b)("code",Object(l.a)({parentName:"pre"},{className:"language-scala"}),"crossoverPSO[S](\n    guide: Guide[S,Double]\n)(implicit M: HasMemory[S,Double])\n")))}p.isMDXComponent=!0},189:function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return O}));var l=a(0),n=a.n(l);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,l)}return a}function c(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,l,n=function(e,t){if(null==e)return{};var a,l,n={},o=Object.keys(e);for(l=0;l<o.length;l++)a=o[l],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(l=0;l<o.length;l++)a=o[l],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var b=n.a.createContext({}),s=function(e){var t=n.a.useContext(b),a=t;return e&&(a="function"==typeof e?e(t):c({},t,{},e)),a},p=function(e){var t=s(e.components);return n.a.createElement(b.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},m=Object(l.forwardRef)((function(e,t){var a=e.components,l=e.mdxType,o=e.originalType,i=e.parentName,b=r(e,["components","mdxType","originalType","parentName"]),p=s(a),u=l,m=p["".concat(i,".").concat(u)]||p[u]||d[u]||o;return a?n.a.createElement(m,c({ref:t},b,{components:a})):n.a.createElement(m,c({ref:t},b))}));function O(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var o=a.length,i=new Array(o);i[0]=m;var c={};for(var r in t)hasOwnProperty.call(t,r)&&(c[r]=t[r]);c.originalType=e,c[u]="string"==typeof e?e:l,i[1]=c;for(var b=2;b<o;b++)i[b]=a[b];return n.a.createElement.apply(null,i)}return n.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);