(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{145:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"rightToc",(function(){return s})),n.d(t,"metadata",(function(){return r})),n.d(t,"default",(function(){return p}));var a=n(1),i=n(9),l=(n(0),n(189)),o={id:"lenses",title:"Lenses"},s=[{value:"Immutable data",id:"immutable-data",children:[]},{value:"Mem",id:"mem",children:[]},{value:"A Quick Look at Entity",id:"a-quick-look-at-entity",children:[]},{value:"Classy Lenses",id:"classy-lenses",children:[{value:"HasMemory",id:"hasmemory",children:[]},{value:"HasVelocity",id:"hasvelocity",children:[]},{value:"HasCharge and HasPBestStagnation",id:"hascharge-and-haspbeststagnation",children:[]},{value:"Conclusion",id:"conclusion",children:[]}]},{value:"Lenses Object",id:"lenses-object",children:[{value:"_state",id:"_state",children:[]},{value:"_position",id:"_position",children:[]},{value:"_vector",id:"_vector",children:[]},{value:"_solutionPrism",id:"_solutionprism",children:[]},{value:"_objectiveLens",id:"_objectivelens",children:[]},{value:"_singleObjective",id:"_singleobjective",children:[]},{value:"_multiObjective",id:"_multiobjective",children:[]},{value:"_singleFit",id:"_singlefit",children:[]},{value:"_singleFitness",id:"_singlefitness",children:[]},{value:"_feasible",id:"_feasible",children:[]}]},{value:"Summary",id:"summary",children:[]}],r={id:"community-tutorial/lenses",title:"Lenses",description:"Great! You just learnt about creating positions in a search space.",source:"@site/docs/community-tutorial/lenses.md",permalink:"/docs/community-tutorial/lenses"},c={rightToc:s,metadata:r},b="wrapper";function p(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(l.b)(b,Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,'Great! You just learnt about creating positions in a search space.\nBut you might be asking yourself "How can we modify our set positions to explore the search space?"\nAnd this is exactly what we intend to learn in the coming chapter.\nWell, partly.\nThis chapter is going to focus on ',Object(l.b)("inlineCode",{parentName:"p"},"Lenses"),", which are super awesome getters, setters and more!\nCILib makes use of the two optics from the ","[",Object(l.b)("inlineCode",{parentName:"p"},"monocle"),"][Monocle-link]"," library."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"[",Object(l.b)("inlineCode",{parentName:"li"},"Lens"),"][lens-link]"),Object(l.b)("li",{parentName:"ul"},"[",Object(l.b)("inlineCode",{parentName:"li"},"Prism"),"][prism-link]")),Object(l.b)("p",null,"I deeply encourage you to check out ","[",Object(l.b)("inlineCode",{parentName:"p"},"monocle"),"][Monocle-link]"," if you are not familiar with any of the concepts I just mentioned.\nThe use of these optics is beneficial as they allow us to create a new ",Object(l.b)("em",{parentName:"p"},"mutated")," instance while still preserving the original.\nOr they may shed light on an instance by ",Object(l.b)("em",{parentName:"p"},"zooming")," in and getting/returning data."),Object(l.b)("div",{class:"callout callout-danger"},Object(l.b)("p",null,"Lenses provide an API that is first and foremost, composition and lawful.\nThis means that the various optics are well behaved and rules exist that\ngovern their usage. Furthermore, different optics may be composed together\nto create new optics that are the combination of the original optics. This\nis obviously only possible if the provided types correctly line up."),Object(l.b)("p",null,'Building on the usage of optics in general, we use a mechanism known as\n"classy lens" in Haskell. This mechanism prevents invalid usage, by letting\nthe compiler fail based on the types being used. In the case of ',Object(l.b)("inlineCode",{parentName:"p"},"Entity"),",\nthe compiler would look up instances, using its implicit resolution rules,\nto obtain evidence for a typeclass with a given set of types, at compile time."),Object(l.b)("p",null,"This provides an additional level of surety, that the data being passed to\na function that requires evidence in order to extract some other piece of\ninformation for a given type. The scala compiler provides the evidence\nthrough the use of its implicit lookup mechanics.")),Object(l.b)("p",null,"Now that you understand the motivation for ",Object(l.b)("inlineCode",{parentName:"p"},"Lenses")," we can start to look at what CILib offers us.\nIf you are still a bit unclear about optics then hopefully the following sections will clear that up as we go through some examples.\nJust one last thing.\nYou might have picked up that ","[Gary][link-gary]"," made reference to something called ",Object(l.b)("inlineCode",{parentName:"p"},"Entity"),".\nFear not as this will be explained more in detail soon in this chapter and the next chapter, which is all about ",Object(l.b)("inlineCode",{parentName:"p"},"Entity"),"."),Object(l.b)("h2",{id:"immutable-data"},"Immutable data"),Object(l.b)("p",null,"To understand a bit more of the motivation behind lenses here is an excerpt from the ","[CILib docs][cilib-docs]","."),Object(l.b)("div",{class:"callout callout-danger"},Object(l.b)("p",null,'Immutable data is fantastic because it allows anyone to read the contents\nof the data and provides the security that the data will not change. In some\ncases, however, we would like to "change" some data value. Using immutable\ndata means that we cannot change the value within a structure, instead we\nneed to create an updated view of the data with the changes applied. This\nupdated view creates new data, where the old data is still present and\nunchanged. It\'s recommended that the reader become familiar with\npersistent data structures and how they operate. Due to how persistent\ndata structures update, by only changing the smallest number of references,\nthe needed speed and efficiency is achieved.'),Object(l.b)("p",null,"Scala tries to help with respect to immutable data, by providing a convenience\nmethod on all ",Object(l.b)("inlineCode",{parentName:"p"},"case class"),"es called ",Object(l.b)("inlineCode",{parentName:"p"},"copy"),'. In situations where there is a\nnesting of case classes, potentially several levels, the updating of a value\non the lower levels results in a bubbling-up process whereby each previous\nlayer needs to update the reference to the new data in the lower layer.\nAlthough this is not difficult to do, the result is very verbose and\nextremely cumbersome for the user. It would be nice if this "zooming"\nupdate process was abstracted behind a data structure that would hide and\nautomate the tedious process.')),Object(l.b)("h2",{id:"mem"},"Mem"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Mem")," is a data type that represents a particle's memory.\nIt contains only two pieces information, both which are valuable.\nThis information being:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"A particle's best ",Object(l.b)("inlineCode",{parentName:"li"},"Position")),Object(l.b)("li",{parentName:"ul"},"A particle's velocity in the form of a ",Object(l.b)("inlineCode",{parentName:"li"},"Position"))),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"Mem")," class is represented with the following definition/constructor:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Mem[A](b: Position[A], v: Position[A])"))),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Mem")," ins't a complex data type at all but it is very important to CILib.\nWe will now see why."),Object(l.b)("h2",{id:"a-quick-look-at-entity"},"A Quick Look at Entity"),Object(l.b)("p",null,"An instance of ",Object(l.b)("inlineCode",{parentName:"p"},"Entity")," represents a particle with in a search space.\nIt has the following constructor:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Entity[S,A](state: S, pos: Position[A])"))),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"state")," member value represents the state of a particle.\nThis in our case is ",Object(l.b)("inlineCode",{parentName:"p"},"Mem"),", but it would also be possible for you to define your own state if you choose to.\nAnd ",Object(l.b)("inlineCode",{parentName:"p"},"pos")," a ",Object(l.b)("inlineCode",{parentName:"p"},"Position")," type to represent the particle's current position."),Object(l.b)("p",null,"Now, if you are familiar with the optics laws form ","[",Object(l.b)("inlineCode",{parentName:"p"},"monocle"),"][Monocle-link]"," you might have already picked up on how ",Object(l.b)("inlineCode",{parentName:"p"},"Entities")," and ",Object(l.b)("inlineCode",{parentName:"p"},"Lenses")," relate.\nSince ",Object(l.b)("inlineCode",{parentName:"p"},"Entity")," is a product of other classes we would want to be able to ",Object(l.b)("em",{parentName:"p"},"zoom")," in on those data types.\nFor example, if we wanted to get a particle's best position we would have to ",Object(l.b)("em",{parentName:"p"},"zoom")," in on its ",Object(l.b)("inlineCode",{parentName:"p"},"Mem")," value.\nThis is where ",Object(l.b)("inlineCode",{parentName:"p"},"Lenses")," come in."),Object(l.b)("p",null,"It also might be beneficial to view ",Object(l.b)("inlineCode",{parentName:"p"},"Entity")," as a collection of information for a particle. It contains a particle's:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Best position"),Object(l.b)("li",{parentName:"ul"},"Velocity"),Object(l.b)("li",{parentName:"ul"},"Current position")),Object(l.b)("h2",{id:"classy-lenses"},"Classy Lenses"),Object(l.b)("div",{class:"callout callout-danger"},Object(l.b)("p",null,'Based on the normally accepted usage of "classy lenses", the type classes\nthat expose the lenses are generally prefixed with ',Object(l.b)("inlineCode",{parentName:"p"},"Has"),".")),Object(l.b)("p",null,"So CILib has some classes that expose the lense for us to use.\nThe reason for this is so that we can define our own functions with the lense.\nThese ",Object(l.b)("em",{parentName:"p"},"classy lenses")," are passed as implicit parameters.\nWe may make muse of:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"HasMemory"),Object(l.b)("li",{parentName:"ul"},"HasVelocity")),Object(l.b)("p",null,"The following code is used to create an ",Object(l.b)("inlineCode",{parentName:"p"},"Entity")," which we will use to explore the class lenses.\nTake note of the evaluated ",Object(l.b)("inlineCode",{parentName:"p"},"Entity")," and its contents."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\nimport spire.implicits.{eu => _, _}\nimport spire.math._\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"\nval interval = Interval(-5.12,5.12)^3\n\nval particle = Position.createPosition(interval).map(p => Entity(Mem(p, p.zeroed), p))\n\nval rng = RNG.init(12)\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"particle.eval(rng)\n")),Object(l.b)("h3",{id:"hasmemory"},"HasMemory"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"HasMemory")," contains a ",Object(l.b)("inlineCode",{parentName:"p"},"Lens")," method that is exposed for use.\nBy importing CILib we are including the implicits that are defined ",Object(l.b)("inlineCode",{parentName:"p"},"HasMemory"),".\nThis allows us to use it in a function were given an ",Object(l.b)("inlineCode",{parentName:"p"},"Entity")," we may retrieve its best ",Object(l.b)("inlineCode",{parentName:"p"},"Position"),"."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"def foo[S](x: Entity[S,Double])(implicit mem: HasMemory[S,Double]) = mem._memory.get(x.state)\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"particle.map(p => foo(p)).eval(rng)\n")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"_memory")," is the ",Object(l.b)("inlineCode",{parentName:"p"},"Lens")," we are using."),Object(l.b)("h3",{id:"hasvelocity"},"HasVelocity"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"HasVelocity")," is works the exact same as ",Object(l.b)("inlineCode",{parentName:"p"},"HasMemory"),".\nThe only difference is that it returns the velocity of an ",Object(l.b)("inlineCode",{parentName:"p"},"Entity's")," state."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"def foo[S](x: Entity[S,Double])(implicit mem: HasVelocity[S,Double]) = mem._velocity.get(x.state)\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"particle.map(p => foo(p)).eval(rng)\n")),Object(l.b)("h3",{id:"hascharge-and-haspbeststagnation"},"HasCharge and HasPBestStagnation"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Todo")),Object(l.b)("h3",{id:"conclusion"},"Conclusion"),Object(l.b)("p",null,"Hopefully the ",Object(l.b)("inlineCode",{parentName:"p"},"HasMemory")," and ",Object(l.b)("inlineCode",{parentName:"p"},"HasVelocity")," examples cleared up any confusion you may have had about optics.\nWe created an ",Object(l.b)("inlineCode",{parentName:"p"},"Entity"),", called ",Object(l.b)("inlineCode",{parentName:"p"},"particle"),", and we saw its contents when we evaluated it.\nWe then used a ",Object(l.b)("inlineCode",{parentName:"p"},"Lens")," to retrieve a part of the contents.\nWe could have even used set, or any other method defined in the ",Object(l.b)("inlineCode",{parentName:"p"},"Lens")," type, to return a new modified result."),Object(l.b)("h2",{id:"lenses-object"},"Lenses Object"),Object(l.b)("p",null,"CILib offers a ",Object(l.b)("inlineCode",{parentName:"p"},"Lense")," object that contains a few optics that we can readily use.\nThese optics are not just for ",Object(l.b)("inlineCode",{parentName:"p"},"Entities")," but also some CILib types we have seen before (yaaay!)\nWith these optics, we are condensing some of the functions we created earlier in to a single line while at the same time adding more functionality (double yaaay!)"),Object(l.b)("p",null,"All optics within the ",Object(l.b)("inlineCode",{parentName:"p"},"Lense")," object are prefixed with an underscore to signify that they are indeed an optic."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"_state[S,A]\n\n_position[S,A]\n\n_vector[A:scalaz.Equal]\n\n_solutionPrism[A]: Prism[Position[A],Solution[A]]\n\n_objectiveLens[A]: Lens[Solution[A],Objective[A]]\n\n_singleObjective[A]: Prism[Objective[A],Single[A]]\n\n_multiObjective[A]: Prism[Objective[A],Multi[A]]\n\n_singleFit[A]: Lens[Single[A],Fit]\n\n_singleFitness[A]: Optional[Position[A], Fit]\n\n_feasible: Prism[Fit,Double]\n")),Object(l.b)("h3",{id:"_state"},"_state"),Object(l.b)("p",null,"Will provide a ",Object(l.b)("inlineCode",{parentName:"p"},"Lens")," that we may use to ",Object(l.b)("em",{parentName:"p"},"zoom")," in on the state of an ",Object(l.b)("inlineCode",{parentName:"p"},"Entity"),"."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib.{Lenses, _}\nimport spire.implicits.{eu => _, _}\n\nimport scalaz._\nimport Scalaz._\nimport spire.math._\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12)\nval interval = Interval(-5.12,5.12)^3\nval particle = Position.createPosition(interval).map(p => Entity(Mem(p, p.zeroed), p))\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val p = particle.eval(rng)\nLenses._state.get(p)\n")),Object(l.b)("h3",{id:"_position"},"_position"),Object(l.b)("p",null,"Will provide a ",Object(l.b)("inlineCode",{parentName:"p"},"Lens")," that we may use to ",Object(l.b)("em",{parentName:"p"},"zoom")," in on the position of an ",Object(l.b)("inlineCode",{parentName:"p"},"Entity"),"."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Lenses._position.get(p)\n")),Object(l.b)("h3",{id:"_vector"},"_vector"),Object(l.b)("p",null,"Returns the actual position within a ",Object(l.b)("inlineCode",{parentName:"p"},"Position")," instance.\nAs of now you have to declare the type being used in the lense."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val x = cilib.Point[Int](NonEmptyList(2, 4), NonEmptyList(Interval(-5.12, 5.12)))\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Lenses._vector[Int].get(x)\n")),Object(l.b)("p",null,"This lense will not work for ",Object(l.b)("inlineCode",{parentName:"p"},"Doubles"),"."),Object(l.b)("h3",{id:"_solutionprism"},"_solutionPrism"),Object(l.b)("p",null,"Will provide a ",Object(l.b)("inlineCode",{parentName:"p"},"Prism"),".\nIf the ",Object(l.b)("inlineCode",{parentName:"p"},"Position")," is a ",Object(l.b)("inlineCode",{parentName:"p"},"Solution")," is will be returned in ",Object(l.b)("inlineCode",{parentName:"p"},"Some"),".\nElse it's a ",Object(l.b)("inlineCode",{parentName:"p"},"Point")," and ",Object(l.b)("inlineCode",{parentName:"p"},"None")," will be returned."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12)\nval interval = Interval(-5.12,5.12)^3\nval e = Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\nval pos = Position.eval(e, Position.createPosition(interval).eval(rng)).eval(rng)\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val solution = Lenses._solutionPrism.getOption(pos).get\n")),Object(l.b)("h3",{id:"_objectivelens"},"_objectiveLens"),Object(l.b)("p",null,"Provides a ",Object(l.b)("inlineCode",{parentName:"p"},"Lens")," that ",Object(l.b)("em",{parentName:"p"},"zooms")," in on the ",Object(l.b)("inlineCode",{parentName:"p"},"Objective")," of a ",Object(l.b)("inlineCode",{parentName:"p"},"Solution")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12)\nval interval = Interval(-5.12,5.12)^3\nval e = Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\nval pos = Position.eval(e, Position.createPosition(interval).eval(rng)).eval(rng)\nval solution = Lenses._solutionPrism.getOption(pos).get\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val objective = Lenses._objectiveLens.get(solution)\n")),Object(l.b)("h3",{id:"_singleobjective"},"_singleObjective"),Object(l.b)("p",null,"Provides a ",Object(l.b)("inlineCode",{parentName:"p"},"Prism"),".\nIf the ",Object(l.b)("inlineCode",{parentName:"p"},"Object")," is a ",Object(l.b)("inlineCode",{parentName:"p"},"Single")," is will be returned in ",Object(l.b)("inlineCode",{parentName:"p"},"Some"),".\nElse it's a ",Object(l.b)("inlineCode",{parentName:"p"},"Multi")," and ",Object(l.b)("inlineCode",{parentName:"p"},"None")," will be returned."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12)\nval interval = Interval(-5.12,5.12)^3\nval e = Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\nval pos = Position.eval(e, Position.createPosition(interval).eval(rng)).eval(rng)\nval solution = Lenses._solutionPrism.getOption(pos).get\nval objective = Lenses._objectiveLens.get(solution)\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val single = Lenses._singleObjective.getOption(objective).get\n")),Object(l.b)("h3",{id:"_multiobjective"},"_multiObjective"),Object(l.b)("p",null,"Works like ",Object(l.b)("inlineCode",{parentName:"p"},"_singleObjective")," but in favour of the ",Object(l.b)("inlineCode",{parentName:"p"},"Multi")," type."),Object(l.b)("h3",{id:"_singlefit"},"_singleFit"),Object(l.b)("p",null,"Provides a ",Object(l.b)("inlineCode",{parentName:"p"},"Lens")," that ",Object(l.b)("em",{parentName:"p"},"zooms")," in on the ",Object(l.b)("inlineCode",{parentName:"p"},"Fit")," of a ",Object(l.b)("inlineCode",{parentName:"p"},"Objective")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12)\nval interval = Interval(-5.12,5.12)^3\nval e = Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\nval pos = Position.eval(e, Position.createPosition(interval).eval(rng)).eval(rng)\nval solution = Lenses._solutionPrism.getOption(pos).get\nval objective = Lenses._objectiveLens.get(solution)\nval single = Lenses._singleObjective.getOption(objective).get\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val fit = Lenses._singleFit.get(single)\n")),Object(l.b)("h3",{id:"_singlefitness"},"_singleFitness"),Object(l.b)("p",null,"Will provide a ",Object(l.b)("inlineCode",{parentName:"p"},"Prism"),".\nIf the ",Object(l.b)("inlineCode",{parentName:"p"},"Position")," is a ",Object(l.b)("inlineCode",{parentName:"p"},"Solution")," its fitness (",Object(l.b)("inlineCode",{parentName:"p"},"Fit"),") will be returned in ",Object(l.b)("inlineCode",{parentName:"p"},"Some"),".\nElse it's a ",Object(l.b)("inlineCode",{parentName:"p"},"Point")," and ",Object(l.b)("inlineCode",{parentName:"p"},"None")," will be returned."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12)\nval interval = Interval(-5.12,5.12)^3\nval e = Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\nval pos = Position.eval(e, Position.createPosition(interval).eval(rng)).eval(rng)\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Lenses._singleFitness.getOption(pos)\n")),Object(l.b)("h3",{id:"_feasible"},"_feasible"),Object(l.b)("p",null,"Will provide a ",Object(l.b)("inlineCode",{parentName:"p"},"Prism"),".\nIf the ",Object(l.b)("inlineCode",{parentName:"p"},"Fit")," is a ",Object(l.b)("inlineCode",{parentName:"p"},"Feasible")," its fitness will be returned in ",Object(l.b)("inlineCode",{parentName:"p"},"Some"),".\nElse it's a ",Object(l.b)("inlineCode",{parentName:"p"},"Infeasible")," and ",Object(l.b)("inlineCode",{parentName:"p"},"None")," will be returned."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12)\nval interval = Interval(-5.12,5.12)^3\nval e = Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\nval pos = Position.eval(e, Position.createPosition(interval).eval(rng)).eval(rng)\nval solution = Lenses._solutionPrism.getOption(pos).get\nval objective = Lenses._objectiveLens.get(solution)\nval single = Lenses._singleObjective.getOption(objective).get\nval fit = Lenses._singleFit.get(single)\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Lenses._feasible.getOption(fit)\n")),Object(l.b)("h2",{id:"summary"},"Summary"),Object(l.b)("p",null,"How great are optics?\nThey provide us with an easy interface with extracting information.\nBut not only a for extracting (getting) we can also use other methods such as ",Object(l.b)("inlineCode",{parentName:"p"},"set")," or ",Object(l.b)("inlineCode",{parentName:"p"},"modifyF")," to return new instances."),Object(l.b)("p",null,"Documentation for the optics types:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"[",Object(l.b)("inlineCode",{parentName:"li"},"Lens"),"][lens-link]"),Object(l.b)("li",{parentName:"ul"},"[",Object(l.b)("inlineCode",{parentName:"li"},"Prism"),"][prism-link]")),Object(l.b)("p",null,"Moving forward, we can begin to see how optics will come in handy when we begin to explore a search space.\nIn the next chapter we will test our newly acquired skills as we begin to put everything together."),Object(l.b)("div",{class:"callout callout-info"},"Optics in CILib use `Lens` and `Prism` that allow us *zoom* in on instances to retrieve information or create new instances."))}p.isMDXComponent=!0},189:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return j}));var a=n(0),i=n.n(a);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),b=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s({},t,{},e)),n},p=function(e){var t=b(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,o=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=b(n),m=a,d=p["".concat(o,".").concat(m)]||p[m]||u[m]||l;return n?i.a.createElement(d,s({ref:t},c,{components:n})):i.a.createElement(d,s({ref:t},c))}));function j(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=d;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s[m]="string"==typeof e?e:a,o[1]=s;for(var c=2;c<l;c++)o[c]=n[c];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);