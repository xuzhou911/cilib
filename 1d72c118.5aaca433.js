(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{137:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"rightToc",(function(){return l})),n.d(t,"metadata",(function(){return s})),n.d(t,"default",(function(){return b}));var a=n(1),r=n(9),i=(n(0),n(189)),o={id:"rvar",title:"RVar"},l=[{value:"The Basics of RVar",id:"the-basics-of-rvar",children:[]},{value:"Some example usage",id:"some-example-usage",children:[]},{value:"Evaluating RVar instances",id:"evaluating-rvar-instances",children:[]}],s={id:"community-tutorial/rvar",title:"RVar",description:"`RVar` (random value) is the backbone data structure of CILib.",source:"@site/docs/community-tutorial/rvar.md",permalink:"/docs/community-tutorial/rvar",sidebar:"docs",previous:{title:"Getting started",permalink:"/docs/community-tutorial/setting-up"}},c={rightToc:l,metadata:s},p="wrapper";function b(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)(p,Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"RVar")," (random value) is the backbone data structure of CILib.\nThe monad instance for ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," allows for sequenced composition, but more importantly enables tracking the effect of applying randomness to the computed value (which the ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," represents).\nTracking the effect of randomness is very important, particularly within Computational Intelligence algorithms, in order to allow for the duplication of computational process.\nIn other words, even if a computation uses randomness, given the same inputs, the same output will be obtained.\nThis ",Object(i.b)("strong",{parentName:"p"},"purity")," (the same inputs producing the same output) allows allows a stochastic process (one which involves randomness) to be represented as a ",Object(i.b)("em",{parentName:"p"},"purely deterministic")," computation.\nThe stochastic nature of the data structure is only relevant when an ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," instance is evaluated into a raw value."),Object(i.b)("blockquote",null,Object(i.b)("h5",Object(a.a)({parentName:"blockquote"},{id:"rvar"}),"RVar"),Object(i.b)("p",{parentName:"blockquote"},"An instance of ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," represents a computation that, when finally evaluated, produces a value with randomness applied.")),Object(i.b)("h2",{id:"the-basics-of-rvar"},"The Basics of RVar"),Object(i.b)("p",null,"Instances of ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," cannot be created without using the predefined functions within the ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," companion object.\nThese functions allow for the creation of basic types that have randomness applied and include:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Integers (",Object(i.b)("inlineCode",{parentName:"li"},"Ints")," and ",Object(i.b)("inlineCode",{parentName:"li"},"Long"),")"),Object(i.b)("li",{parentName:"ul"},"Floating point numbers (",Object(i.b)("inlineCode",{parentName:"li"},"Float")," and ",Object(i.b)("inlineCode",{parentName:"li"},"Double"),")"),Object(i.b)("li",{parentName:"ul"},"Booleans (",Object(i.b)("inlineCode",{parentName:"li"},"True"),"/",Object(i.b)("inlineCode",{parentName:"li"},"False")," values)"),Object(i.b)("li",{parentName:"ul"},"Constant values where the randomness is simply not applied - this is useful when a constant value needs to be used within a calculation of ",Object(i.b)("inlineCode",{parentName:"li"},"RVar"),"s.")),Object(i.b)("p",null,"Other values are built up using these base instances quite easily.\nAdditionally, functions that operate on the types mentioned above are available.\nThese operations are very common operations that would be tedious for the user to maintain and have been included as part of the library.\nIt is recommended to look at the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:""}),"documentation for ",Object(i.b)("inlineCode",{parentName:"a"},"RVar"))," to get a feeling for the available combinator functions."),Object(i.b)("h2",{id:"some-example-usage"},"Some example usage"),Object(i.b)("p",null,"To make the statements in the previous section a little more concrete, let's examine some examples.\nAssume that you need to create a list of random values.\nNow, because we are using a statically-typed language, we cannot mix and match different ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," instances without actually losing information about the contents of a list.\nFor this reason, the ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," companion object allows us to create lists of values using the already defined instances:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val listOfInts = RVar.ints(12)\n// listOfInts: RVar[List[Int]] = cilib.RVar$$anon$4@7e407be1\n")),Object(i.b)("p",null,"So ",Object(i.b)("inlineCode",{parentName:"p"},"listOfInts")," is a ",Object(i.b)("inlineCode",{parentName:"p"},"List[Int]")," of 12 elements, wrapped within a ",Object(i.b)("inlineCode",{parentName:"p"},"RVar"),", that are all randomly generated.\nImportantly, observe that the value of ",Object(i.b)("inlineCode",{parentName:"p"},"listOfInt")," is ",Object(i.b)("em",{parentName:"p"},"not")," 12 random integers, but is simply an instance of ",Object(i.b)("inlineCode",{parentName:"p"},"RVar"),".\nInstances of ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," may be combined to produce new ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," values.\nThe combination of ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," values into new values uses the available ",Object(i.b)("strong",{parentName:"p"},"Functor, Applicative and Monad")," instances for ",Object(i.b)("inlineCode",{parentName:"p"},"RVar"),".\nYou need not concern yourself with that too much, but know that these structures are at work when you combine ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," values using any of the provided combinators or the Scala ",Object(i.b)("em",{parentName:"p"},"for-comprehension")," feature."),Object(i.b)("p",null,"Let's now take ",Object(i.b)("inlineCode",{parentName:"p"},"listOfInts")," and do something with the internal ",Object(i.b)("inlineCode",{parentName:"p"},"List[Int]"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val doubledListOfInts =\n  for {\n    list <- listOfInts\n  } yield list.map(x => x * 2)\n// doubledListOfInts: RVar[List[Int]] = cilib.RVar$$anon$4@3e621a84\n")),Object(i.b)("p",null,"Look at that. Interesting. The value ",Object(i.b)("inlineCode",{parentName:"p"},"doubledListOfInts")," took all list within the ",Object(i.b)("inlineCode",{parentName:"p"},"listOfInts")," and then multiplied each of the elements in the list by 2.\nThe same operation may also be achieved using the ",Object(i.b)("inlineCode",{parentName:"p"},"map")," method on ",Object(i.b)("inlineCode",{parentName:"p"},"RVar"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val doubledListOfIntsAlternative =\n  listOfInts.map(_.map(x => x * 2))\n// doubledListOfIntsAlternative: RVar[List[Int]] = cilib.RVar$$anon$4@6a3c64f7\n")),Object(i.b)("p",null,"The result of ",Object(i.b)("inlineCode",{parentName:"p"},"doubledListOfInts")," and ",Object(i.b)("inlineCode",{parentName:"p"},"doubledListOfIntsAlternative")," is just a ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," value, nothing else.\nThat's quite convenient.\nWe can now create new ",Object(i.b)("inlineCode",{parentName:"p"},"RVar"),"s using existing ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," values and use any method to create these values that is the most comfortable."),Object(i.b)("p",null,"Now that we can create these ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," instances, we would need to evaluate them in order to produce the presented random value."),Object(i.b)("h2",{id:"evaluating-rvar-instances"},"Evaluating RVar instances"),Object(i.b)("p",null,"It should be stressed that the internal value of ",Object(i.b)("inlineCode",{parentName:"p"},"RVar"),' should not be a concern to the user.\nEven though we are playing with these instances now, it should be noted that the library will produce values that should only be evaluated at the "end of the world".\nThe "end of the world" means that the ',Object(i.b)("inlineCode",{parentName:"p"},"RVar"),"s are evaluated at the entry point to your program (often in the ",Object(i.b)("inlineCode",{parentName:"p"},"main")," function).\nUp until that evaluation point, the ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," instances are simply describing the computation process with randomness and are often referred to as sub-programs of the main program."),Object(i.b)("p",null,"Now, to evaulate a ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," instance, the ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," needs to be ",Object(i.b)("em",{parentName:"p"},"executed"),".\nThis execution requires a ",Object(i.b)("inlineCode",{parentName:"p"},"RNG")," value.\n",Object(i.b)("inlineCode",{parentName:"p"},"RNG")," is simply an instance of a pseudo-random number generator, and we suggest the use of the CMWC generator due to the good performance properties and overall power of the generator itself.\n",Object(i.b)("inlineCode",{parentName:"p"},"RNG")," creation is similar to that of ",Object(i.b)("inlineCode",{parentName:"p"},"RVar"),", in that the ",Object(i.b)("inlineCode",{parentName:"p"},"RNG")," companion object's functions should be used to create the values.\nPseudo-random number generators require a starting point, or a ",Object(i.b)("em",{parentName:"p"},"seed")," value.\nThis is the single value that initializes the internal state of the generator, and is the single value required to produce the same result from the same ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," program.\nThe ability to reproduce values, even though randomness is involved, is the most crucial feature of the library.\nReproduction allows others to obtain the same results for a given experiment / algorithm execution, which in turn allows for simplified error correction and validation of results."),Object(i.b)("p",null,"Let's create a ",Object(i.b)("inlineCode",{parentName:"p"},"RNG")," value and evaluate one of the previously created ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," instances:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"// Our seed is 1234\nval rng = RNG.init(1234)\n// rng: RNG = cilib.CMWC@6cfcf6dc\n\nval result = doubledListOfInts.run(rng)\n// result: (RNG, List[Int]) = (\n//   cilib.CMWC@4a7553b4,\n//   List(\n//     270407222,\n//     -912624788,\n//     1077819590,\n//     854019630,\n//     -970459794,\n//     -1946478236,\n//     -1210620186,\n//     -325849792,\n//     1159678500,\n//     1219035670,\n//     -307371322,\n//     -1513169218\n//   )\n// )\n")),Object(i.b)("p",null,"The value of the ",Object(i.b)("inlineCode",{parentName:"p"},"result")," is interesting.\nIt is a tuple of two values, a ",Object(i.b)("inlineCode",{parentName:"p"},"RNG")," as well as a ",Object(i.b)("inlineCode",{parentName:"p"},"List[Int]")," of evaluated randomised integers.\nThe ",Object(i.b)("inlineCode",{parentName:"p"},"RNG")," part of the result is the state of the new state of the ",Object(i.b)("inlineCode",{parentName:"p"},"RNG")," after the evaluation of the ",Object(i.b)("inlineCode",{parentName:"p"},"RVar"),".\nBy returning the updated state, it allows for the threading of the ",Object(i.b)("inlineCode",{parentName:"p"},"RNG")," through another ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," computation.\nIt might seem that such threading could be error prone, and that is totally correct and also the reason why the ",Object(i.b)("inlineCode",{parentName:"p"},"Monad")," instance for ",Object(i.b)("inlineCode",{parentName:"p"},"RVar")," is responsible for such threading, instead of the user."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"RVar")," is a specialized ",Object(i.b)("strong",{parentName:"p"},"state monad"),", with the ",Object(i.b)("inlineCode",{parentName:"p"},"RNG")," being the state, and therefore correctly handles the state updates internally."))}b.isMDXComponent=!0},189:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return h}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},b=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=p(n),u=a,m=b["".concat(o,".").concat(u)]||b[u]||d[u]||i;return n?r.a.createElement(m,l({ref:t},c,{components:n})):r.a.createElement(m,l({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);