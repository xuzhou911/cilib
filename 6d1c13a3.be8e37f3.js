(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{151:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"rightToc",(function(){return o})),n.d(t,"metadata",(function(){return l})),n.d(t,"default",(function(){return b}));var a=n(1),i=n(9),p=(n(0),n(189)),r={id:"step",title:"Step"},o=[{value:"Environment",id:"environment",children:[]},{value:"Step Class",id:"step-class",children:[{value:"map",id:"map",children:[]},{value:"flatMap",id:"flatmap",children:[]}]},{value:"Step Companion Object",id:"step-companion-object",children:[{value:"point",id:"point",children:[]},{value:"pointR",id:"pointr",children:[]},{value:"eval",id:"eval",children:[]},{value:"withCompare",id:"withcompare",children:[]},{value:"withCompareR",id:"withcomparer",children:[]},{value:"evalF",id:"evalf",children:[]}]},{value:"Summary",id:"summary",children:[]}],l={id:"community-tutorial/step",title:"Step",description:"What is this mysterious data type called `Step`? Well, it actually",source:"@site/docs/community-tutorial/step.md",permalink:"/docs/community-tutorial/step"},c={rightToc:o,metadata:l},s="wrapper";function b(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(p.b)(s,Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(p.b)("p",null,"What is this mysterious data type called ",Object(p.b)("inlineCode",{parentName:"p"},"Step"),"? Well, it actually\nrepresents a ",Object(p.b)("em",{parentName:"p"},"step")," in an algorithm. Nothing mysterious at all. How\ndoes this happen? ",Object(p.b)("inlineCode",{parentName:"p"},"Step")," is a monad transformer and because monad\ntransformers are monads themselves, we can freely compose different\nStep instances to create a larger computation."),Object(p.b)("p",null,"In the last chapter we learnt how to create ",Object(p.b)("inlineCode",{parentName:"p"},"Entities"),", but what about\nevaluating them? This wil be our first introduction to ",Object(p.b)("inlineCode",{parentName:"p"},"Step"),"."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\nimport spire.implicits._\nimport spire.math._\nimport scalaz._\nimport Scalaz._\n")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12)\nval bounds = Interval(-5.12,5.12)^2\n\nval env = Environment(\n        cmp = Comparison.dominance(Min),\n        eval = Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\n    )\n\nval particle = Position.createPosition(bounds).map(p => Entity(Mem(p, p.zeroed), p)).eval(rng)\ndef explore (position: Position[Double]): Position[Double] = position.map(x => x * 0.73)\n")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val myStep = Step.eval(explore)(particle)\n")),Object(p.b)("p",null,"This ",Object(p.b)("inlineCode",{parentName:"p"},"Step")," represents a step in some algorithm where the particle's\nposition is updated and evaluated to return a new ",Object(p.b)("inlineCode",{parentName:"p"},"Entity"),"."),Object(p.b)("p",null,"Understanding the ",Object(p.b)("inlineCode",{parentName:"p"},"Step")," concept is important as we will begin to\nstart making more complex ",Object(p.b)("em",{parentName:"p"},"steps")," that which may be used in an\nalgorithm."),Object(p.b)("h2",{id:"environment"},"Environment"),Object(p.b)("p",null,"An environment is simply a ",Object(p.b)("em",{parentName:"p"},"container")," for the specifications of our\nproblem. And as we can see from the class definition, it uses types\nwe are very familiar with."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{}),"final case class Environment[A](\n    cmp: Comparison,\n    eval: RVar[NonEmptyList[A] => Objective[A]])\n")),Object(p.b)("p",null,"An example of creating an ",Object(p.b)("inlineCode",{parentName:"p"},"Environment")," would be the following..."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\nimport scalaz._\nimport Scalaz._\nimport spire.math.Interval\nimport spire.implicits.{eu => _, _}\n\n")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val env = Environment(\n    cmp = Comparison.dominance(Min),\n    eval =  Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\n)\n")),Object(p.b)("h2",{id:"step-class"},"Step Class"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"Step")," is has a very simple class definition. It takes a single\nparameter, that being a function of type ",Object(p.b)("inlineCode",{parentName:"p"},"Environment[A] => RVar[B]"),".\nWe see this member function used we we call ",Object(p.b)("inlineCode",{parentName:"p"},"run")," of a ",Object(p.b)("inlineCode",{parentName:"p"},"Step"),"."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{}),"final case class Step[A,B] private (run: Environment[A] => RVar[B])\n")),Object(p.b)("p",null,"Not complicated at all. And because of its monadic nature we have\nthe following functions at our disposal."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"map[C](f: B => C): Step[A,C]\n\nflatMap[C](f: B => Step[A,C]): Step[A,C]\n")),Object(p.b)("p",null,"We will be using the ",Object(p.b)("inlineCode",{parentName:"p"},"Step")," we created at the beginning of this\nchapter, ",Object(p.b)("inlineCode",{parentName:"p"},"myStep"),"."),Object(p.b)("h3",{id:"map"},"map"),Object(p.b)("p",null,"Here we changing the context of the ",Object(p.b)("inlineCode",{parentName:"p"},"Step"),"."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\nimport spire.implicits._\nimport spire.math._\nimport scalaz._\nimport Scalaz._\n\nval bounds = Interval(-5.12,5.12)^2\n\nval env = Environment(\n    cmp = Comparison.dominance(Min),\n    eval =  Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\n)\n\nval rng = RNG.init(12)\nval particle = Position.createPosition(bounds).map(p => Entity(Mem(p, p.zeroed), p)).eval(rng)\ndef explore (position: Position[Double]): Position[Double] = position.map(x => x * 0.73)\nval myStep = Step.eval(explore)(particle)\n")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"myStep.map(entity => Lenses._position.get(entity)).run(env).eval(rng)\n")),Object(p.b)("p",null,"In this example we changed it from"),Object(p.b)("ul",null,Object(p.b)("li",{parentName:"ul"},"a step in where the particle's position is updated and evaluated to\nreturn a new ",Object(p.b)("inlineCode",{parentName:"li"},"Entity")),Object(p.b)("li",{parentName:"ul"},"to a step in where the particle's position is updated and evaluated\nto return the resulting ",Object(p.b)("inlineCode",{parentName:"li"},"Position"),".")),Object(p.b)("h3",{id:"flatmap"},"flatMap"),Object(p.b)("p",null,"Here we changing the context. In this example, We are passing an\n",Object(p.b)("inlineCode",{parentName:"p"},"Entity[A] => Step[A, C]"),", thus producing a new ",Object(p.b)("inlineCode",{parentName:"p"},"Step[A, C]")," which\nwill differ from our original ",Object(p.b)("inlineCode",{parentName:"p"},"Step[A, B]"),". What will happen here is\nthat we adding an extra ",Object(p.b)("em",{parentName:"p"},"step"),"."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12)\ndef explore (position: Position[Double]): Position[Double] = position.map(x => x * 0.73)\nval particle = Position.createPosition(bounds).map(p => Entity(Mem(p, p.zeroed), p)).eval(rng)\nval myStep = Step.eval(explore)(particle)\n\ndef negate (position: Position[Double]): Position[Double] = position.map(x => x * -1)\n")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"myStep.flatMap(entity => Step.eval(negate)(particle)).run(env).eval(rng)\n")),Object(p.b)("p",null,"So now our ",Object(p.b)("inlineCode",{parentName:"p"},"Step")," represents a step in an algorithm where a position\nis multiplied by 0.73 and then negated. This step might not serve any\nreal world purpose but it demonstrates how we may chain ",Object(p.b)("inlineCode",{parentName:"p"},"Steps"),"\ntogether to form an algorithm. This is easily achieved by using for\ncomprehensions. For example, take a look at the following method."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"def algorithm(entity: Entity[Mem[Double], Double]) = (for {\n    step1 <- Step.eval(explore)(entity)\n    step2 <- Step.eval(negate)(entity)\n} yield step2).map(entity => Lenses._position.get(entity))\n\nalgorithm(particle).run(env).eval(rng)\n")),Object(p.b)("h2",{id:"step-companion-object"},"Step Companion Object"),Object(p.b)("p",null,"The companion object offers several methods that we may use to create\ninstances of ",Object(p.b)("inlineCode",{parentName:"p"},"Steps"),"."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"point[A,B](b: B): Step[A,B]\n\npointR[A,B](a: RVar[B]): Step[A,B]\n\neval[S,A:Numeric](f: Position[A] => Position[A])(entity: Entity[S,A]): Step[A,Entity S,A]\n\nevalP[A](pos: Position[A]): Step[A,Position[A]]\n\nwithCompare[A,B](a: Comparison => B): Step[A,B]\n\nwithCompareR[A,B](f: Comparison => RVar[B]): Step[A,B]\n\nevalF[A:Numeric](pos: Position[A]): Step[A,Position[A]]\n")),Object(p.b)("p",null,"We will be using the ",Object(p.b)("inlineCode",{parentName:"p"},"Environment")," and ",Object(p.b)("inlineCode",{parentName:"p"},"RNG")," we created at the\nbeginning of this chapter."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{}),"val rng = RNG.init(12)\nval bounds = Interval(-5.12,5.12)^2\nval env = Environment(\n    cmp = Comparison.dominance(Min),\n    eval = Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\n)\n")),Object(p.b)("h3",{id:"point"},"point"),Object(p.b)("p",null,"Returns an instance of ",Object(p.b)("inlineCode",{parentName:"p"},"Step")," based on the given parameter."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\nimport spire.implicits._\nimport spire.math._\nimport scalaz._\nimport Scalaz._\nval rng = RNG.init(12)\nval bounds = Interval(-5.12,5.12)^2\nval env = Environment(\n    cmp = Comparison.dominance(Min),\n    eval = Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\n)\n")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val particle = Position.createPosition(bounds).map(p => Entity(Mem(p, p.zeroed), p)).eval(rng)\n")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Step.point(particle)\n")),Object(p.b)("h3",{id:"pointr"},"pointR"),Object(p.b)("p",null,"Creates ",Object(p.b)("inlineCode",{parentName:"p"},"Step")," contained in ",Object(p.b)("inlineCode",{parentName:"p"},"RVar"),"."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val particle = Position.createPosition(bounds).map(p => Entity(Mem(p, p.zeroed), p))\n")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Step.pointR(particle).run(env).eval(rng)\n")),Object(p.b)("h3",{id:"eval"},"eval"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"eval")," is used for evaluating ",Object(p.b)("inlineCode",{parentName:"p"},"Entities"),". This function produces a\n",Object(p.b)("inlineCode",{parentName:"p"},"Step")," which may be ",Object(p.b)("inlineCode",{parentName:"p"},"run")," using a function, ",Object(p.b)("inlineCode",{parentName:"p"},"Environment => RVar[A]"),"."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val particle = Position.createPosition(bounds).map(p => Entity(Mem(p, p.zeroed), p)).eval(rng)\ndef explore (position: Position[Double]): Position[Double] = position.map(x => x * 0.73)\n\nStep.eval(explore)(particle)\n")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"Step.eval(explore)(particle).run(env).run(rng)\n")),Object(p.b)("p",null,"As you can see from the above code, when our ",Object(p.b)("inlineCode",{parentName:"p"},"Entity")," was evaluated\nit's ",Object(p.b)("inlineCode",{parentName:"p"},"Point")," changed to a ",Object(p.b)("inlineCode",{parentName:"p"},"Solution"),". However its ",Object(p.b)("inlineCode",{parentName:"p"},"state")," remained\nthe same as that is up to us as to how we update it."),Object(p.b)("h3",{id:"withcompare"},"withCompare"),Object(p.b)("p",null,"An example of use would be comparing the current position of an\n",Object(p.b)("inlineCode",{parentName:"p"},"Entity")," with its best, and then returning a new ",Object(p.b)("inlineCode",{parentName:"p"},"Entity")," based on\nthe comparison."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"import monocle._, Monocle._\n\nval particle = Position.createPosition(bounds).map(p => Entity(Mem(p, p.zeroed), p)).eval(rng)\n\ndef updatePBest[S](p: Entity[S,Double])(implicit M: HasMemory[S,Double]): Step[Double, Entity[S,Double]] = {\n    val pbestL = M._memory\n    Step.withCompare(Comparison.compare(p.pos, (p.state applyLens pbestL).get)).map(x =>\n        Entity(p.state applyLens pbestL set x, p.pos))\n}\n")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"updatePBest(particle).run(env).eval(rng)\n")),Object(p.b)("h3",{id:"withcomparer"},"withCompareR"),Object(p.b)("p",null,"An example of use would be determining which un-evaluated\n",Object(p.b)("inlineCode",{parentName:"p"},"RVar[Entity]s")," is fitter."),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"def better[S,A](a: Entity[S,A], b: Entity[S,A]): Step[A,Boolean] =\n    Step.withCompareR(comp => RVar.point(Comparison.fitter(a.pos, b.pos).apply(comp)))\n\nval particle1 = Position.createPosition(bounds).map(p => Entity(Mem(p, p.zeroed), p)).eval(rng)\nval particle2 = Position.createPosition(bounds).map(p => Entity(Mem(p, p.zeroed), p)).eval(RNG.fromTime)\n")),Object(p.b)("pre",null,Object(p.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Betterk(particle1, particle2).run(env).eval(rng)\n")),Object(p.b)("h3",{id:"evalf"},"evalF"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"evalF")," will take a ",Object(p.b)("inlineCode",{parentName:"p"},"Position")," an returns a ",Object(p.b)("inlineCode",{parentName:"p"},"Step")," that represents the\nevaluation of the position. This is actually used in the ",Object(p.b)("inlineCode",{parentName:"p"},"Step.eval"),"\nmethod."),Object(p.b)("h2",{id:"summary"},"Summary"),Object(p.b)("p",null,"Hey, that wasn't as scary as we thought it would be."),Object(p.b)("p",null,":::note\n",Object(p.b)("inlineCode",{parentName:"p"},"Step")," is nothing more than a data structure that hides the details of a\nmonad transformer which represents the algorithmic parts which my be applied to a given problem ",Object(p.b)("inlineCode",{parentName:"p"},"Environment"),".\n:::"),Object(p.b)("p",null,"We also learnt some valuable skills in this chapter such as:"),Object(p.b)("p",null,":::note"),Object(p.b)("ul",null,Object(p.b)("li",{parentName:"ul"},"We can use for comprehensions to chain together steps of an algorithm."),Object(p.b)("li",{parentName:"ul"},"How to can compare two ",Object(p.b)("inlineCode",{parentName:"li"},"Entities")," in a step.\n:::")),Object(p.b)("p",null,"But what if I told you ",Object(p.b)("inlineCode",{parentName:"p"},"Step")," has a sibling?\n",Object(p.b)("em",{parentName:"p"},"gasp"),".\nIn the next chapter we are going to look at ",Object(p.b)("inlineCode",{parentName:"p"},"StepS")," which represents a step with a state."))}b.isMDXComponent=!0},189:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return O}));var a=n(0),i=n.n(a);function p(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){p(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},p=Object.keys(e);for(a=0;a<p.length;a++)n=p[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(a=0;a<p.length;a++)n=p[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),s=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o({},t,{},e)),n},b=function(e){var t=s(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,p=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=s(n),m=a,d=b["".concat(r,".").concat(m)]||b[m]||u[m]||p;return n?i.a.createElement(d,o({ref:t},c,{components:n})):i.a.createElement(d,o({ref:t},c))}));function O(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var p=n.length,r=new Array(p);r[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[m]="string"==typeof e?e:a,r[1]=o;for(var c=2;c<p;c++)r[c]=n[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);