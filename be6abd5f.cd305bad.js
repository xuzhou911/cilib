(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{169:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"rightToc",(function(){return o})),t.d(n,"metadata",(function(){return c})),t.d(n,"default",(function(){return p}));var a=t(1),i=t(9),l=(t(0),t(189)),r={id:"eval",title:"Eval"},o=[{value:"Unconstrained",id:"unconstrained",children:[{value:"eval",id:"eval",children:[]},{value:"constrainBy",id:"constrainby",children:[]},{value:"unconstrain",id:"unconstrain",children:[]}]},{value:"Constrained",id:"constrained",children:[{value:"eval",id:"eval-1",children:[]},{value:"constrainBy",id:"constrainby-1",children:[]},{value:"unconstrain",id:"unconstrain-1",children:[]}]},{value:"How Would We Use Eval?",id:"how-would-we-use-eval",children:[]},{value:"Summary",id:"summary",children:[]}],c={id:"community-tutorial/eval",title:"Eval",description:"In the last chapter we saw how to test if a set of numbers satisfies a `Constraint` or a violates `Constraints`.",source:"@site/docs/community-tutorial/eval.md",permalink:"/docs/community-tutorial/eval"},s={rightToc:o,metadata:c},b="wrapper";function p(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(l.b)(b,Object(a.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(l.b)("p",null,"In the last chapter we saw how to test if a set of numbers satisfies a ",Object(l.b)("inlineCode",{parentName:"p"},"Constraint")," or a violates ",Object(l.b)("inlineCode",{parentName:"p"},"Constraints"),".\nWe now are going to look at how to unconstrained or constrained evaluations in CILib.\n",Object(l.b)("inlineCode",{parentName:"p"},"Eval")," useful in the sense that it provides a platform to determine whether a set of values are a feasible or\ninfeasible solution and how to handle them respectively."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"unconstrained[F[_]: Input, A](f: F[A] => Double): Eval[A]\n\nconstrained[F[_]: Input, A](f: F[A] => Double, cs: List[Constraint[A, Double]]): Eval[A]\n")),Object(l.b)("p",null,"The above a methods belong to the ",Object(l.b)("inlineCode",{parentName:"p"},"Eval")," object with each creating their own version of an ",Object(l.b)("inlineCode",{parentName:"p"},"Eval")," instance.\nAlthough they produce slightly different ",Object(l.b)("inlineCode",{parentName:"p"},"Evals"),", let's look at what ",Object(l.b)("inlineCode",{parentName:"p"},"Eval")," has to offer."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"eval(a: NonEmptyList[A]): RVar[Objective[A]]\n\nconstrainBy(cs: List[Constraint[A,Double]]): Eval[A]\n\nunconstrain: Eval[A]\n")),Object(l.b)("p",null,"The methods for constructing ",Object(l.b)("inlineCode",{parentName:"p"},"Evals")," also share some similarities. First, the type parameters, ",Object(l.b)("inlineCode",{parentName:"p"},"[F[_]: Input, A]"),".\n",Object(l.b)("inlineCode",{parentName:"p"},"[F[_]: Input")," simply means that we need a monad, in this case a ",Object(l.b)("inlineCode",{parentName:"p"},"NonEmptyList"),", of type ",Object(l.b)("inlineCode",{parentName:"p"},"A"),".\nSecondly, in both methods, we pass a function that takes our monad and produces a ",Object(l.b)("inlineCode",{parentName:"p"},"Double")," (",Object(l.b)("inlineCode",{parentName:"p"},"f: F[A] => Double"),")."),Object(l.b)("h2",{id:"unconstrained"},"Unconstrained"),Object(l.b)("div",{class:"callout callout-info"},"An unconstrained evaluation applies a function that takes a monad and produces a double in a contained environment. Every solution is feasible since there are not constraints."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\nimport scalaz._\nimport Scalaz._\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val e = Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml)\n")),Object(l.b)("p",null,"Here, we are creating an unconstrained evaluation instance that produces the sum of a non-empty list where each element is squared.\nWith our newly created instance we can use the following methods."),Object(l.b)("h3",{id:"eval"},"eval"),Object(l.b)("p",null,"Will return a function that produces an ",Object(l.b)("inlineCode",{parentName:"p"},"Objective"),", either ",Object(l.b)("inlineCode",{parentName:"p"},"Single")," or ",Object(l.b)("inlineCode",{parentName:"p"},"Multi")," with a ",Object(l.b)("inlineCode",{parentName:"p"},"Feasible")," solution as there is no constraints.\nThis function is wrapped in an ",Object(l.b)("inlineCode",{parentName:"p"},"RVar"),". So in oder to ",Object(l.b)("em",{parentName:"p"},"extract")," the function from within the ",Object(l.b)("inlineCode",{parentName:"p"},"RVar")," we can use ",Object(l.b)("inlineCode",{parentName:"p"},"run"),".\nFinally, we may use our function with other given list."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val l = NonEmptyList(20.0, 4.0, 5.0)\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"e.eval\ne.eval.run(RNG.fromTime)\ne.eval.run(RNG.fromTime)._2\ne.eval.run(RNG.fromTime)._2.apply(l)\n")),Object(l.b)("h3",{id:"constrainby"},"constrainBy"),Object(l.b)("p",null,"Will return a new instance of a constrained ",Object(l.b)("inlineCode",{parentName:"p"},"Eval")," based on the parameter provided and the existing ",Object(l.b)("inlineCode",{parentName:"p"},"Eval's")," ",Object(l.b)("em",{parentName:"p"},"evaluation")," function."),Object(l.b)("h3",{id:"unconstrain"},"unconstrain"),Object(l.b)("p",null,"This will return itself."),Object(l.b)("h2",{id:"constrained"},"Constrained"),Object(l.b)("div",{class:"callout callout-info"},"An unconstrained evaluation applies a function that takes a monad and produces a double in a contained environment. The feasibility of every solution is determined by the constraints."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\nimport scalaz._\nimport Scalaz._\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val lesThanCons = LessThan(ConstraintFunction((l: NonEmptyList[Double]) => l.suml), 12.0)\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val e = Eval.constrained[NonEmptyList,Double](_.map(x => x * x).suml, List(lesThanCons))\n")),Object(l.b)("h3",{id:"eval-1"},"eval"),Object(l.b)("p",null,"Performs the same function as an unconstrained.\nHowever, our result may either be feasible or infeasible.\nIf it is infeasible, you will notice that the result contains a violation count as well a ",Object(l.b)("inlineCode",{parentName:"p"},"List")," of the violated ",Object(l.b)("inlineCode",{parentName:"p"},"Constraints"),"."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"var l = NonEmptyList(20.0, 4.0, 5.0)\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"e.eval.run(RNG.fromTime)._2.apply(l)\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"l = NonEmptyList(1.0, 4.0, 5.0)\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"e.eval.run(RNG.fromTime)._2.apply(l)\n")),Object(l.b)("h3",{id:"constrainby-1"},"constrainBy"),Object(l.b)("p",null,"Will return a new instance of a constrained ",Object(l.b)("inlineCode",{parentName:"p"},"Eval")," based on the parameter provided and the existing ",Object(l.b)("inlineCode",{parentName:"p"},"Eval's")," ",Object(l.b)("em",{parentName:"p"},"evaluation")," function.\nNote that the existing ",Object(l.b)("inlineCode",{parentName:"p"},"Constraints")," are not carried over, they are replaced by the parameter."),Object(l.b)("h3",{id:"unconstrain-1"},"unconstrain"),Object(l.b)("p",null,"Will return a new instance of a unconstrained ",Object(l.b)("inlineCode",{parentName:"p"},"Eval")," based on the existing ",Object(l.b)("inlineCode",{parentName:"p"},"Eval's")," ",Object(l.b)("em",{parentName:"p"},"evaluation")," function."),Object(l.b)("h2",{id:"how-would-we-use-eval"},"How Would We Use Eval?"),Object(l.b)("p",null,"Okay, so we know what ",Object(l.b)("inlineCode",{parentName:"p"},"Eval")," ",Object(l.b)("em",{parentName:"p"},"is"),", but what can we do with it?\nSay there exists a problem called problem X.\nIt requires 4 numbers.\nWhere all numbers need to be in the interval of 0 and 50.\nHowever, there are some constraints."),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"The third number needs to be greater than 20."),Object(l.b)("li",{parentName:"ol"},"Our fitness function can't yield a result greater than 5.")),Object(l.b)("p",null,"Our fitness function will add the first three numbers, and divide the result by the fourth.\nPretty simple. So far we have.."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\nimport scalaz._\nimport Scalaz._\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"def fitness (values: NonEmptyList[Double]) : Double = {\n    var result = values.index(0).getOrElse(0.0)\n    result += values.index(1).getOrElse(0.0)\n    result += values.index(2).getOrElse(0.0)\n    result /= values.index(3).getOrElse(0.0)\n    result\n}\nval cons1 = GreaterThan(ConstraintFunction((l: NonEmptyList[Double]) => l.index(3).getOrElse(0.0)), 20.0)\nval cons2 = LessThanEqual(ConstraintFunction((l: NonEmptyList[Double]) => fitness(l)), 5.0)\n\nval e = Eval.constrained[NonEmptyList,Double](fitness(_), List( cons1, cons2))\n")),Object(l.b)("p",null,"Cool. We know that when we use an ",Object(l.b)("inlineCode",{parentName:"p"},"Eval")," it will return an ",Object(l.b)("inlineCode",{parentName:"p"},"Objective"),", ",Object(l.b)("em",{parentName:"p"},"the objective of a function"),".\nSince we know the ",Object(l.b)("inlineCode",{parentName:"p"},"Objective")," is going to be ",Object(l.b)("inlineCode",{parentName:"p"},"Single")," we should focus our attention there.\nA ",Object(l.b)("inlineCode",{parentName:"p"},"Single")," will contain a ",Object(l.b)("inlineCode",{parentName:"p"},"Fit")," type, either ",Object(l.b)("inlineCode",{parentName:"p"},"Feasible")," or ",Object(l.b)("inlineCode",{parentName:"p"},"Infeasible"),", as well as a ",Object(l.b)("inlineCode",{parentName:"p"},"List")," of\nany ",Object(l.b)("inlineCode",{parentName:"p"},"Constraints")," that were violated."),Object(l.b)("p",null,"Because of all the class types being used we are able to use pattern matching in order to control our\nprogram logic."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"def getSolution (fit: Fit) : Double = {\n    fit match {\n        case Feasible(v) => v\n        case Infeasible(_, _) => -1.0\n        case Adjusted (_, _) => -1.0\n    }\n}\n\ndef evalObjective (objective: Objective[Double]) : Double = {\n    objective match {\n        case Single(f, _) => getSolution(f)\n        case Multi(_) => -1.0\n    }\n}\n")),Object(l.b)("p",null,"As you can see, we are using -1.0 to indicate an infeasible solution."),Object(l.b)("p",null,"Now we can put everything together and test our code."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import spire.implicits._\nimport spire.math.Interval\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12L)\nval interval = Interval(0.0, 50.0)\nval l = Dist.uniform(interval).replicateM(4).eval(rng).toNel.getOrElse(NonEmptyList(0.0))\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"evalObjective(e.eval.run(rng)._2(l))\n")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},".toNel.getOrElse(NonEmptyList(0.0))")," is converting the returned ",Object(l.b)("inlineCode",{parentName:"p"},"List[Double]")," from our ",Object(l.b)("inlineCode",{parentName:"p"},"RVar")," evaluation to ",Object(l.b)("inlineCode",{parentName:"p"},"NonEmptyList[Double]"),"."),Object(l.b)("h2",{id:"summary"},"Summary"),Object(l.b)("p",null,"In this chapter we got to explore the useful concept of ",Object(l.b)("inlineCode",{parentName:"p"},"Eval")," and how we would use it in a very basic example.\nSeeing as there are no exercises for this chapter, I encourage you to modify the example or come up with your own use of ",Object(l.b)("inlineCode",{parentName:"p"},"Eval"),".\nThis is so that you can solidify your understanding of ",Object(l.b)("inlineCode",{parentName:"p"},"Eval")," as will be making use of it in the coming chapters."),Object(l.b)("div",{class:"callout callout-info"},"`Eval` is a type that allows us to evaluate a `NonEmptyList` of numbers using a given function, while optionally applying a given `List` of `Constraints`.",Object(l.b)("p",null,"To do this we use the ",Object(l.b)("inlineCode",{parentName:"p"},"eval")," method. We could either get a ",Object(l.b)("inlineCode",{parentName:"p"},"Single")," or ",Object(l.b)("inlineCode",{parentName:"p"},"Multi Objective")," as a result.\nWhere ",Object(l.b)("inlineCode",{parentName:"p"},"Single")," could contain a ",Object(l.b)("inlineCode",{parentName:"p"},"Feasible")," or ",Object(l.b)("inlineCode",{parentName:"p"},"Infeasible")," solution with a ",Object(l.b)("inlineCode",{parentName:"p"},"List")," of ",Object(l.b)("inlineCode",{parentName:"p"},"Constraints")," violated\n(this list will be empty if it's a ",Object(l.b)("inlineCode",{parentName:"p"},"Feasible")," solution).\n",Object(l.b)("inlineCode",{parentName:"p"},"Multi")," will contain a ",Object(l.b)("inlineCode",{parentName:"p"},"List")," of ",Object(l.b)("inlineCode",{parentName:"p"},"Single Objectives"),"."),Object(l.b)("p",null,"Because of the types returned we are able to use pattern matching to account for every situation and control\nwhat the flow of the program logic.")),Object(l.b)("p",null,"In the following chapter we will look at the concept that we briefly touched upon, ",Object(l.b)("inlineCode",{parentName:"p"},"Fit"),"."))}p.isMDXComponent=!0},189:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return O}));var a=t(0),i=t.n(a);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=i.a.createContext({}),b=function(e){var n=i.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o({},n,{},e)),t},p=function(e){var n=b(e.components);return i.a.createElement(s.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},d=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,r=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=b(t),u=a,d=p["".concat(r,".").concat(u)]||p[u]||m[u]||l;return t?i.a.createElement(d,o({ref:n},s,{components:t})):i.a.createElement(d,o({ref:n},s))}));function O(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,r=new Array(l);r[0]=d;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o[u]="string"==typeof e?e:a,r[1]=o;for(var s=2;s<l;s++)r[s]=t[s];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);