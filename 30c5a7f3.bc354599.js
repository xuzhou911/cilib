(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{141:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"rightToc",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"default",(function(){return p}));var a=n(1),i=n(9),o=(n(0),n(189)),l={id:"position",title:"Position"},r=[{value:"Position Companion Object",id:"position-companion-object",children:[{value:"eval",id:"eval",children:[]},{value:"createPosition",id:"createposition",children:[]},{value:"createPositions",id:"createpositions",children:[]},{value:"createCollection",id:"createcollection",children:[]}]},{value:"Position Class",id:"position-class",children:[{value:"pos",id:"pos",children:[]},{value:"boundary",id:"boundary",children:[]},{value:"zip",id:"zip",children:[]},{value:"take",id:"take",children:[]},{value:"drop",id:"drop",children:[]},{value:"objective",id:"objective",children:[]},{value:"toPoint",id:"topoint",children:[]},{value:"map",id:"map",children:[]},{value:"flatMap",id:"flatmap",children:[]},{value:"traverse",id:"traverse",children:[]},{value:"forall",id:"forall",children:[]}]},{value:"Maths With Positions",id:"maths-with-positions",children:[]},{value:"Summary",id:"summary",children:[]}],s={id:"community-tutorial/position",title:"Position",description:":::caution",source:"@site/docs/community-tutorial/position.md",permalink:"/docs/community-tutorial/position"},c={rightToc:r,metadata:s},b="wrapper";function p(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)(b,Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,":::caution\nCandidate solution vectors within a search space are the basic pieces of information that computational algorithms maintain and,\nincludes feature vectors that represent training patterns in a neural network.\nWithin population based algorithms, a collection of algorithm participants are employed in a search of the problem space.\nEach represents a possible solution to the problem at hand, and may be in one of two possible states:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},'It may be a "point" in the search space where no other information about the point is known, except for the value of the multi-dimensional vector representing the position within the search space'),Object(o.b)("li",{parentName:"ol"},'It may be a possible "solution", where the position in the multi-dimensional search space is known but, an additional value representing the "quality" of the vector is also maintained. This "quality" is referred to as the fitness of the candidate solution.\n:::')),Object(o.b)("p",null,"The above explanation was provided by ","[Gary Pampar\xe0][link-gary]"," on the ","[CILib docs project][cilib-docs]",".\nUp until now we have primarily been generating random candidate solutions and evaluating them.\nIn the last chapter's questions we briefly looked at modifying candidate solutions.\nHowever, we weren't really exploring the search space.\nIn this chapter we will look at CILib's ",Object(o.b)("inlineCode",{parentName:"p"},"Position")," data type and how we can start defining search spaces."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Position")," is a data structure that can either be a:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Point")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Solution"))),Object(o.b)("p",null,"Because of these two classes we are able to represent the above cases that Gary mentioned perfectly.\n",Object(o.b)("inlineCode",{parentName:"p"},"Point")," has the following constructor ",Object(o.b)("inlineCode",{parentName:"p"},"Point(x: NonEmptyList[A], b: NonEmptyList[Interval[Double]])")," where"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"x is a list of point that make up the position in the search space."),Object(o.b)("li",{parentName:"ul"},"b are the intervals that which the points lie in.")),Object(o.b)("p",null,"While ",Object(o.b)("inlineCode",{parentName:"p"},"Solution")," contains these, as well an ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," to represent its fitness.\nThus has the following constructor ",Object(o.b)("inlineCode",{parentName:"p"},"Solution(x: NonEmptyList[A], b: NonEmptyList[Interval[Double]], o: Objective[A])"),".\nAny changes to a ",Object(o.b)("inlineCode",{parentName:"p"},"Solution")," will result in a ",Object(o.b)("inlineCode",{parentName:"p"},"Point"),".\nRemember that a ",Object(o.b)("inlineCode",{parentName:"p"},"Solution")," is ",Object(o.b)("inlineCode",{parentName:"p"},"Point")," with a fitness evaluation."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Position")," is Algebraic Data Type (ADT) meaning that the set of possible representations may not be extended.\nAnd of course, we are provided with a companion object.\nUnlike other chapters we are first going to explore the companion object before we go any further."),Object(o.b)("p",null,":::note\nThis is the first chapter were you are going to be using ","[Refined][Refined-link]",".\nThe following imports should be sufficient"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"import cilib._\nimport scalaz._\nimport Scalaz._\n\nimport eu.timepit.refined.auto._\n\nimport spire.implicits.{eu => _, _}\nimport spire.math.Interval\n")),Object(o.b)("p",null,":::"),Object(o.b)("h2",{id:"position-companion-object"},"Position Companion Object"),Object(o.b)("p",null,"The companion object offers a few ways for us create instances of a ",Object(o.b)("inlineCode",{parentName:"p"},"Position")," or collections of ",Object(o.b)("inlineCode",{parentName:"p"},"Positions"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"eval[A](e: Eval[A], pos: Position[A]): RVar[Position[A]]\n\ncreatePosition[A](domain: NonEmptyList[Interval[Double]]): RVar[Position[A]]\n\ncreatePositions(domain: NonEmptyList[Interval[Double]], n: Int Refined GreaterEqual[_1]): RVar[List[Position[A]]]\n\ncreateCollection[A](f: Position[Double] => A)(domain: NonEmptyList[Interval[Double]], n: Int Refined GreaterEqual[_1]): RVar[List[A]]\n")),Object(o.b)("p",null,"There is also a handful implicit definitions within the object definition that if you want can check out over here ","[here][cilib-position-object]","."),Object(o.b)("p",null,"You might have noticed that these methods all return an ",Object(o.b)("inlineCode",{parentName:"p"},"RVar[A]"),".\nThis is because we want to generate random positions within our search space.\nAnd due to ",Object(o.b)("inlineCode",{parentName:"p"},"Position's")," class definition we will be able to transform our ",Object(o.b)("inlineCode",{parentName:"p"},"Positions")," within the ",Object(o.b)("inlineCode",{parentName:"p"},"RVar")," context."),Object(o.b)("p",null,"As we explore the object will be making use of the following code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12)\n")),Object(o.b)("h3",{id:"eval"},"eval"),Object(o.b)("p",null,"For ",Object(o.b)("inlineCode",{parentName:"p"},"eval")," we will need to supply a ",Object(o.b)("inlineCode",{parentName:"p"},"Position"),", which we will create, as well as a list of ",Object(o.b)("inlineCode",{parentName:"p"},"Intervals"),".\nThis method will an ",Object(o.b)("inlineCode",{parentName:"p"},"RVar")," of type ",Object(o.b)("inlineCode",{parentName:"p"},"Solution")," (another ",Object(o.b)("inlineCode",{parentName:"p"},"Position"),"type)."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"import cilib._\nimport spire.implicits.{eu => _, _}\nimport spire.math._\nimport scalaz._\nimport Scalaz._\n\nval rng = RNG.init(12)\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val e = Eval.unconstrained[NonEmptyList,Double](vec => Feasible(vec.map(x => x * x).suml)).eval\nval list = NonEmptyList(5.0, 4)\nval intervals = NonEmptyList(Interval(0.0, 4.0), Interval(8.0, 9.0))\nval point = cilib.Point(list, intervals)\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Position.eval(e, point).run(rng)\n")),Object(o.b)("h3",{id:"createposition"},"createPosition"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"createPosition")," will return a ",Object(o.b)("inlineCode",{parentName:"p"},"RVar[Position[A]]"),", where this ",Object(o.b)("inlineCode",{parentName:"p"},"Position")," will be a ",Object(o.b)("inlineCode",{parentName:"p"},"Point"),".\nWhen the ",Object(o.b)("inlineCode",{parentName:"p"},"RVar")," is ",Object(o.b)("em",{parentName:"p"},"run"),", it will produce the usual tuple we are familiar with, where the ",Object(o.b)("inlineCode",{parentName:"p"},"Point")," will contain a randomly generated number\nfor each ",Object(o.b)("inlineCode",{parentName:"p"},"Interval")," (dimension).\nEach ",Object(o.b)("inlineCode",{parentName:"p"},"Interval")," in the list represents a dimension.\nThe ",Object(o.b)("inlineCode",{parentName:"p"},"Intervals")," do not need to be the same, meaning we can have different ",Object(o.b)("inlineCode",{parentName:"p"},"Intervals")," for different dimensions.\nThe use of ",Object(o.b)("inlineCode",{parentName:"p"},"NonEmptyLists")," ensure that we will, at minimum, we have one dimension."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Position.createPosition(intervals).run(rng)\n")),Object(o.b)("p",null,"CILib also adds some syntax has been added to the ",Object(o.b)("inlineCode",{parentName:"p"},"Interval")," data constructor to allow for repetition in a more convenient way.\nAllowing us to create multi dimensional positions with ease."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Position.createPosition(Interval(-5.12,5.12)^5)\n")),Object(o.b)("p",null,"We created a 5 dimensional search space where each dimension ranges from -5.12 to 5.12"),Object(o.b)("h3",{id:"createpositions"},"createPositions"),Object(o.b)("p",null,"Like ",Object(o.b)("inlineCode",{parentName:"p"},"createPosition"),", but will result in a ",Object(o.b)("inlineCode",{parentName:"p"},"RVar")," of a list of ",Object(o.b)("inlineCode",{parentName:"p"},"Positions"),".\nWhere n is the size of the parameter."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"import eu.timepit.refined.auto._\nval intervals = NonEmptyList(Interval(0.0, 4.0), Interval(8.0, 9.0))\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val pos = Position.createPositions(intervals, 2)\n")),Object(o.b)("h3",{id:"createcollection"},"createCollection"),Object(o.b)("p",null,"Like ",Object(o.b)("inlineCode",{parentName:"p"},"createPositions"),", but will result in a ",Object(o.b)("inlineCode",{parentName:"p"},"RVar")," of a list of ",Object(o.b)("inlineCode",{parentName:"p"},"A"),".\nWe are able to have a result of ",Object(o.b)("inlineCode",{parentName:"p"},"List[A]")," because the method allows us to pass our own function as a parameter."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"import eu.timepit.refined.auto._\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"Position.createCollection(x => x)(intervals, 2).run(rng)\nPosition.createCollection(x => x.map(_ * 2))(intervals, 2).run(rng)\n")),Object(o.b)("h2",{id:"position-class"},"Position Class"),Object(o.b)("p",null,"Great. Now that we know how to create positions we may look at what we can do with the ",Object(o.b)("inlineCode",{parentName:"p"},"Position")," instances,\n",Object(o.b)("inlineCode",{parentName:"p"},"Point")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Solution"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"pos: NonEmptyList[A]\n\nboundary: NonEmptyList[Interval[A]]\n\nzip[B](other: Position[B]): Position[(A, B)]\n\ntake(n: Int): IList[A]\n\ndrop(n: Int): IList[A]\n\nobjective: Option[Objective[A]]\n\ntoPoint: Position[A]\n\nmap[B](f: A => B): Position[B]\n\nflatMap[B](f: A => Position[B]): Position[B]\n\ntraverse[G[_]: Applicative, B](f: A => G[B]): G[Position[B]]\n\nforall(f: A => Boolean)\n")),Object(o.b)("p",null,"Now you might recognize some, if not most, of these functions from your own experience with scala.\nAnd since this book is not only a guide of CILib but also to serve as documentation, we will quickly check out these methods."),Object(o.b)("p",null,"We will be using the following code to test the methods."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\nimport spire.implicits._\nimport spire.math._\nimport scalaz._\nimport Scalaz._\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(12)\nval e = Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\nval intervals = NonEmptyList(Interval(0.0, 4.0), Interval(8.0, 9.0))\nval myPos = Position.createPosition(intervals).eval(rng)\n")),Object(o.b)("h3",{id:"pos"},"pos"),Object(o.b)("p",null,"Returns the actual position."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"myPos.pos\n")),Object(o.b)("h3",{id:"boundary"},"boundary"),Object(o.b)("p",null,"Returns the boundary."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"myPos.boundary\n")),Object(o.b)("h3",{id:"zip"},"zip"),Object(o.b)("p",null,"Combines the values of two ",Object(o.b)("inlineCode",{parentName:"p"},"Positions")," instances in to one instance."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val otherPos = Position.createPosition(intervals).eval(RNG.fromTime)\nmyPos.zip(otherPos)\n")),Object(o.b)("h3",{id:"take"},"take"),Object(o.b)("p",null,"Returns n amount of points from the ",Object(o.b)("inlineCode",{parentName:"p"},"Position"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"myPos.take(1)\n")),Object(o.b)("h3",{id:"drop"},"drop"),Object(o.b)("p",null,"Does the same as take."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"myPos.drop(1)\n")),Object(o.b)("h3",{id:"objective"},"objective"),Object(o.b)("p",null,"Will return the objective of a ",Object(o.b)("inlineCode",{parentName:"p"},"Position"),". If the ",Object(o.b)("inlineCode",{parentName:"p"},"Position")," is a"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Point")," it will return ",Object(o.b)("inlineCode",{parentName:"li"},"none")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Solution")," will return ",Object(o.b)("inlineCode",{parentName:"li"},"some(o)")," where ",Object(o.b)("inlineCode",{parentName:"li"},"o")," is the parameter.")),Object(o.b)("h3",{id:"topoint"},"toPoint"),Object(o.b)("p",null,"Will convert a ",Object(o.b)("inlineCode",{parentName:"p"},"Position")," into a ",Object(o.b)("inlineCode",{parentName:"p"},"Point")," type."),Object(o.b)("h3",{id:"map"},"map"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"myPos.map(x => x * 0.2)\n")),Object(o.b)("h3",{id:"flatmap"},"flatMap"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"myPos.flatMap(x => cilib.Point(NonEmptyList(x * 2), myPos.boundary))\n")),Object(o.b)("h3",{id:"traverse"},"traverse"),Object(o.b)("p",null,"If we had a list of 3 and 8, and we wanted a list where each element is -x and / or 2x.\nThe list would be:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"-3, -8"),Object(o.b)("li",{parentName:"ul"},"-3, 16"),Object(o.b)("li",{parentName:"ul"},"6, -8"),Object(o.b)("li",{parentName:"ul"},"6, 18")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"myPos.traverse(x => NonEmptyList(x * -1, x * 2))\n")),Object(o.b)("h3",{id:"forall"},"forall"),Object(o.b)("p",null,"Applies a condition to each element."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"myPos.forall(x => x > 1)\n")),Object(o.b)("h2",{id:"maths-with-positions"},"Maths With Positions"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Positions")," also may be used with normal vector operations.\nThis allows for simpler usage as it mirrors the mathematics defined in literature more closely."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\nimport spire.implicits._\nimport spire.math._\nimport scalaz._\nimport Scalaz._\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"val rng = RNG.init(1234L)\nval e = Eval.unconstrained[NonEmptyList,Double](_.map(x => x*x).suml).eval\nval a = Position.createPosition(Interval(-5.12,5.12)^3).eval(rng)\nval b = Position.createPosition(Interval(-5.12,5.12)^3).flatMap(p => Position.eval(e, p)).eval(rng)\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"a + b // Add Point and Solution\na + a // Add Point and Point\nb + b // Add Solution and Solution\na - b // Subtract Solution from Point\n")),Object(o.b)("h2",{id:"summary"},"Summary"),Object(o.b)("p",null,"CILib makes creating search spaces incredibly easy.\nAnd with this we can start making our programs simpler while adding more functionality.\nFor example, in the previous chapter you were asked to create a program to solve for a cost effective solution for building a bow and arrow. With search spaces it could look something like this..."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":invisible",":invisible":!0}),"import cilib._\nimport scalaz._\nimport Scalaz._\n\nimport eu.timepit.refined.auto._\n\nimport spire.implicits.{eu => _, _}\nimport spire.math.Interval\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),'val rng = RNG.init(12)\nval e = Eval.unconstrained[NonEmptyList,Double](_.map(x => x * x).suml).eval\n\nval rng = RNG.init(12L)\ndef fitness (l: NonEmptyList[Double]): Double = l.suml\nval distanceConstraint = GreaterThanEqual(ConstraintFunction((l: NonEmptyList[Double]) => l.index(0).getOrElse(0)) , 38)\nval damageConstraint = GreaterThanEqual(ConstraintFunction((l: NonEmptyList[Double]) => l.index(1).getOrElse(0)), 520)\nval e = Eval.constrained[NonEmptyList, Double](fitness(_), List( damageConstraint, distanceConstraint)).eval\nval intervals = NonEmptyList(Interval(0.0, 5.0), Interval(0.0, 10.0))\n\nval result = for {\n     positions <- Position.createPositions(intervals, 5) // This creates a NonEmptyList[Position] for us\n     evaluated <- positions.traverse(p => Position.eval(e, p)) // We need to "traverse" the collection so that we apply the given function to all values within the RVar sub-program\n} yield evaluated\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"result.eval(rng)\n")),Object(o.b)("p",null,":::info\n",Object(o.b)("inlineCode",{parentName:"p"},"Position")," allows us points in a search space.\nThese points can then be evaluated which will yield a solution.\nA solution is a point with a fitness evaluation.\n:::"))}p.isMDXComponent=!0},189:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return j}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),b=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r({},t,{},e)),n},p=function(e){var t=b(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=b(n),m=a,d=p["".concat(l,".").concat(m)]||p[m]||u[m]||o;return n?i.a.createElement(d,r({ref:t},c,{components:n})):i.a.createElement(d,r({ref:t},c))}));function j(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[m]="string"==typeof e?e:a,l[1]=r;for(var c=2;c<o;c++)l[c]=n[c];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);