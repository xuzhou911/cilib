(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{158:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"rightToc",(function(){return p})),n.d(t,"metadata",(function(){return r})),n.d(t,"default",(function(){return b}));var a=n(1),i=n(9),o=(n(0),n(189)),l={id:"step-with-state",title:"StepS"},p=[{value:"StepS Class",id:"steps-class",children:[{value:"Our First StepS",id:"our-first-steps",children:[]},{value:"zoom",id:"zoom",children:[]},{value:"map",id:"map",children:[]},{value:"flatMap",id:"flatmap",children:[]}]},{value:"StepS Companion Object",id:"steps-companion-object",children:[{value:"lensIso",id:"lensiso",children:[]},{value:"apply",id:"apply",children:[]},{value:"pointR",id:"pointr",children:[]},{value:"pointS",id:"points",children:[]},{value:"liftK",id:"liftk",children:[]},{value:"liftS",id:"lifts",children:[]}]},{value:"Summary",id:"summary",children:[]}],r={id:"community-tutorial/step-with-state",title:"StepS",description:"At this point, we now understand what `Step` is.",source:"@site/docs/community-tutorial/stepS.md",permalink:"/docs/community-tutorial/step-with-state"},s={rightToc:p,metadata:r},c="wrapper";function b(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)(c,Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"At this point, we now understand what ",Object(o.b)("inlineCode",{parentName:"p"},"Step")," is.\n",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," is very similar but now we are creating a step with a state."),Object(o.b)("p",null,"What is a state?\nLets first at look functions to answer this.\nA ",Object(o.b)("em",{parentName:"p"},"state-ful")," computation is something that takes some state and returns a value along with some new state.\nIn a way we could look at ",Object(o.b)("inlineCode",{parentName:"p"},"RVar")," as state-ful computation as we supply at state, the ",Object(o.b)("inlineCode",{parentName:"p"},"RNG"),", and when it is run a value is returned along with a new state."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"s -> (a, s)\n")),Object(o.b)("p",null,"Thus, ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," represents a ",Object(o.b)("inlineCode",{parentName:"p"},"Step")," with a step.\nNow since we haven't come across any ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," instances before this, we will first look at what a ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," is made up off."),Object(o.b)("h2",{id:"steps-class"},"StepS Class"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"final case class StepS[A,S,B](run: StateT[Step[A,?],S,B])")),Object(o.b)("p",null,"As you can see the class header bares some resemblance to that of\n",Object(o.b)("inlineCode",{parentName:"p"},"Step"),". Here, however, the parameter ",Object(o.b)("inlineCode",{parentName:"p"},"run")," is a state transformer,\n",Object(o.b)("inlineCode",{parentName:"p"},"StateT"),". ",Object(o.b)("inlineCode",{parentName:"p"},"StateT")," is defined in ",Object(o.b)("inlineCode",{parentName:"p"},"scalaz"),". The other similarities\nare that ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," also has ",Object(o.b)("inlineCode",{parentName:"p"},"map")," and ",Object(o.b)("inlineCode",{parentName:"p"},"flatmap")," methods."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"def map[C](f: B => C): StepS[A,S,C]\n\ndef flatMap[C](f: B => StepS[A,S,C]): StepS[A,S,C]\n")),Object(o.b)("p",null,"But what also makes ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," unique is its ",Object(o.b)("inlineCode",{parentName:"p"},"zoom")," method."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"def zoom[S2](l: monocle.Lens[S2,S]): StepS[A,S2,B]\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"zoom")," method uses a type of lense from the ",Object(o.b)("inlineCode",{parentName:"p"},"monocle")," library,\ncalled ",Object(o.b)("inlineCode",{parentName:"p"},"Iso"),". Information about ",Object(o.b)("inlineCode",{parentName:"p"},"iso")," can be found over here at this\n","[link][iso-link]",". We will see how all of these new data types come as\nwe start by creating our first ",Object(o.b)("inlineCode",{parentName:"p"},"StepS"),"!"),Object(o.b)("h3",{id:"our-first-steps"},"Our First StepS"),Object(o.b)("p",null,"Imagine we had the following situation. We wanted to update a\nposition by adjusting each point by some factor, as well as producing\na new factor. We would end up with some return type of\n",Object(o.b)("inlineCode",{parentName:"p"},"(Position[Double], Double)"),". All while keeping the same ",Object(o.b)("em",{parentName:"p"},"chaining"),"\nfor comprehension ability of of ",Object(o.b)("inlineCode",{parentName:"p"},"Step"),". Tada! ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," to save the\nday. In this situation, our factor will be our state. First, the\nbasics."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"import cilib._\nimport scalaz._\nimport Scalaz._\nimport spire.implicits._\nimport spire.math.Interval\nimport _root_.eu.timepit.refined.auto._\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val bounds = Interval(-5.12,5.12)^2\n\nval env = Environment(\n    cmp = Comparison.dominance(Min),\n    eval = Eval.unconstrained[NonEmptyList,Double](p => Feasible(_.map(x => x * x).suml)).eval\n)\nval rng = RNG.init(12)\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"// Our Position\nval position = Position.createPosition(bounds).eval(rng)\n")),Object(o.b)("p",null,"And then here is our function that we will be using to get an updated\n",Object(o.b)("inlineCode",{parentName:"p"},"Position")," and state."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"def explore (position: Position[Double], factor: Double): (Position[Double], Double) =\n    (position.map(x => x * factor), 0.73 * factor)\n")),Object(o.b)("p",null,"Now, putting it all together to make a ",Object(o.b)("inlineCode",{parentName:"p"},"StepS"),". Pay close attention\nto the resulting types."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val myStepS = StepS(StateT[Step[Double, ?], Position[Double], Double](x => Step.point(explore(x, 0.96))))\nval step = myStepS.run(position) // Supply an initial value\nval rvar = step.run(env)\nval result = rvar.eval(rng)\n")),Object(o.b)("p",null,"Now that we have a ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," at our disposal let's start looking at its\nclass methods."),Object(o.b)("h3",{id:"zoom"},"zoom"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"zoom")," allows us to plugin in a lens for our ",Object(o.b)("inlineCode",{parentName:"p"},"StepS"),". In this case,\nusing ",Object(o.b)("inlineCode",{parentName:"p"},"zoom")," with a ",Object(o.b)("inlineCode",{parentName:"p"},"_position")," lense we are able to pass an ",Object(o.b)("inlineCode",{parentName:"p"},"Entity"),".\nThis creates a ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," that offers the same functionality as our\noriginal but allows us to pass in a different data type."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val particle = Position.createPosition(bounds).map(p => Entity((), p)).eval(rng)\nmyStepS.zoom(Lenses._position[Unit, Double]).run(particle).run(env).eval(rng)\n")),Object(o.b)("h3",{id:"map"},"map"),Object(o.b)("p",null,"Using the ",Object(o.b)("inlineCode",{parentName:"p"},"map")," method we are able to modify the state value."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"myStepS.map(x => 4.0 * x).run(position).run(env).eval(rng)\n")),Object(o.b)("h3",{id:"flatmap"},"flatMap"),Object(o.b)("p",null,"Similarly, using the ",Object(o.b)("inlineCode",{parentName:"p"},"flatMap")," method we are able to modify the state\nas well as the value at hand by chaining together ",Object(o.b)("inlineCode",{parentName:"p"},"StepS"),"s."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"def negate (position: Position[Double]): (Position[Double], Double) = (position.map(x => x * -1), -1.0)\nval myStepS2 = StepS(StateT[Step[Double, ?], Position[Double], Double](x => Step.point(negate(x))))\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala",metastring:":silent",":silent":!0}),"myStepS.flatMap(x => myStepS2).run(position).run(env).eval(rng)\n")),Object(o.b)("p",null,"Although a simple example with having our state has a ",Object(o.b)("inlineCode",{parentName:"p"},"Double"),", we can\nbegin to see its usefulness. Especially when we begin to use it in\nfor comprehensions to chain multiple ",Object(o.b)("inlineCode",{parentName:"p"},"StepSs")," together. The last\nfocus of this chapter will be exploring the companion object."),Object(o.b)("h2",{id:"steps-companion-object"},"StepS Companion Object"),Object(o.b)("p",null,"The companion object offers us several methods for us to use, which we\nwill explore shortly."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"lensIso[A,B]\n\napply[A,S,B](f: S => Step[A,(S, B)]): StepS[A,S,B]\n\npointR[A,S,B](a: RVar[B]): StepS[A,S,B]\n\npointS[A,S,B](a: Step[A,B]): StepS[A,S,B]\n\nliftK[A,S,B](a: Comparison => B): StepS[A,S,B]\n\nliftS[A,S,B](a: State[S, B]): StepS[A,S,B]\n")),Object(o.b)("p",null,"Not only does it offer us ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," creation methods, there are two\nimplicits that you should be mindful about."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"implicit def stepSMonad[A,S]: Monad[StepS[A,S,?]]\n\nimplicit def stepSMonadState[A,S]: MonadState[StepS[A,S,?], S]\n")),Object(o.b)("h3",{id:"lensiso"},"lensIso"),Object(o.b)("p",null,"This method allows us to transform a ",Object(o.b)("inlineCode",{parentName:"p"},"scalaz")," lense into a ",Object(o.b)("inlineCode",{parentName:"p"},"monocle"),"\nlenses that we may use."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"StepS.lensIso.get(scalaz.Lens.firstLens[Unit, Double])\n")),Object(o.b)("h3",{id:"apply"},"apply"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"apply"),' we have seen before in the previous section, specifically "Our\nFirst StepS" where you can find a thorough example.'),Object(o.b)("h3",{id:"pointr"},"pointR"),Object(o.b)("p",null,"Creating a ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," based on an ",Object(o.b)("inlineCode",{parentName:"p"},"RVar")," computation. It is important to\nremember that the initial value for ",Object(o.b)("inlineCode",{parentName:"p"},"run")," is a state value, the second\ntype parameter. In this case ",Object(o.b)("inlineCode",{parentName:"p"},"Double"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"StepS.pointR[Double, Double, NonEmptyList[Entity[Unit,Double]]](Position.createCollection(x => Entity((), x))(bounds, 3))\n")),Object(o.b)("h3",{id:"points"},"pointS"),Object(o.b)("p",null,"Creating a ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," based on an ",Object(o.b)("inlineCode",{parentName:"p"},"Step")," computation."),Object(o.b)("h3",{id:"liftk"},"liftK"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"liftK")," when provided with a comparison will yield ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," based on a\n",Object(o.b)("inlineCode",{parentName:"p"},"Step.withCompare"),"."),Object(o.b)("h3",{id:"lifts"},"liftS"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"liftS")," when provided with a ",Object(o.b)("inlineCode",{parentName:"p"},"State")," will yield ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")," with a state\ntype of ",Object(o.b)("inlineCode",{parentName:"p"},"State"),"."),Object(o.b)("h2",{id:"summary"},"Summary"),Object(o.b)("p",null,"Again. Not that scary.\nIt really depends on what you decide to use as your state."),Object(o.b)("div",{class:"callout callout-info"},"A *state-ful* computation is something that takes some state and returns a value along with some new state. `StepS` represents a `Step` with a step. When we `run` a `StepS` we need to supply an initial state value. The type of the initial state value is determined by the second type parameter of the `StepS`."),Object(o.b)("p",null,"In the next chapter we will gain some practical experience with ",Object(o.b)("inlineCode",{parentName:"p"},"Step")," as well as a bit of ",Object(o.b)("inlineCode",{parentName:"p"},"StepS")))}b.isMDXComponent=!0},189:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return O}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=i.a.createContext({}),c=function(e){var t=i.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):p({},t,{},e)),n},b=function(e){var t=c(e.components);return i.a.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,s=r(e,["components","mdxType","originalType","parentName"]),b=c(n),u=a,d=b["".concat(l,".").concat(u)]||b[u]||m[u]||o;return n?i.a.createElement(d,p({ref:t},s,{components:n})):i.a.createElement(d,p({ref:t},s))}));function O(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=d;var p={};for(var r in t)hasOwnProperty.call(t,r)&&(p[r]=t[r]);p.originalType=e,p[u]="string"==typeof e?e:a,l[1]=p;for(var s=2;s<o;s++)l[s]=n[s];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);